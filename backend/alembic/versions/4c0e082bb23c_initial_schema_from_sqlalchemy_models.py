"""Initial schema from SQLAlchemy models

Revision ID: 4c0e082bb23c
Revises:
Create Date: 2025-12-28 15:28:16.698924

"""

from collections.abc import Sequence

import sqlalchemy as sa
from alembic import op
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision: str = "4c0e082bb23c"
down_revision: str | None = None
branch_labels: str | Sequence[str] | None = None
depends_on: str | Sequence[str] | None = None


def upgrade() -> None:
    """Upgrade schema."""
    #     # ### commands auto generated by Alembic - please adjust! ###
    #     op.drop_index(
    #         "idx_normalized_categories_active", table_name="normalized_categories"
    #     )
    #     op.drop_index("idx_normalized_categories_name", table_name="normalized_categories")
    #     op.drop_index(
    #         "idx_normalized_categories_system", table_name="normalized_categories"
    #     )
    #     op.drop_table("normalized_categories", cascade=True)
    #     op.drop_index("idx_gmail_oauth_state_expires", table_name="gmail_oauth_state")
    #     op.drop_index("idx_gmail_oauth_state_state", table_name="gmail_oauth_state")
    #     op.drop_table("gmail_oauth_state", cascade=True)
    #     op.drop_table("truelayer_oauth_state", cascade=True)
    #     op.drop_table("account_mappings", cascade=True)
    #     op.drop_index("idx_matching_jobs_celery_task", table_name="matching_jobs")
    #     op.drop_index("idx_matching_jobs_user_status", table_name="matching_jobs")
    #     op.drop_table("matching_jobs", cascade=True)
    #     op.drop_table("truelayer_connections", cascade=True)
    #     op.drop_index("idx_parse_stats_job", table_name="gmail_parse_statistics")
    #     op.drop_index("idx_parse_stats_merchant", table_name="gmail_parse_statistics")
    #     op.drop_index(
    #         "idx_parse_stats_merchant_method", table_name="gmail_parse_statistics"
    #     )
    #     op.drop_index("idx_parse_stats_method", table_name="gmail_parse_statistics")
    #     op.drop_index("idx_parse_stats_sender", table_name="gmail_parse_statistics")
    #     op.drop_table("gmail_parse_statistics", cascade=True)
    #     op.drop_index(
    #         "idx_subcategory_mappings_category", table_name="subcategory_mappings"
    #     )
    #     op.drop_index(
    #         "idx_subcategory_mappings_subcategory", table_name="subcategory_mappings"
    #     )
    #     op.drop_table("subcategory_mappings", cascade=True)
    #     op.drop_index(
    #         "idx_ab_matches_order", table_name="truelayer_amazon_business_matches"
    #     )
    #     op.drop_table("truelayer_amazon_business_matches", cascade=True)
    #     op.drop_index(
    #         "idx_enrichment_jobs_created_at", table_name="truelayer_enrichment_jobs"
    #     )
    #     op.drop_index(
    #         "idx_enrichment_jobs_import_job_id", table_name="truelayer_enrichment_jobs"
    #     )
    #     op.drop_index("idx_enrichment_jobs_status", table_name="truelayer_enrichment_jobs")
    #     op.drop_index("idx_enrichment_jobs_user_id", table_name="truelayer_enrichment_jobs")
    #     op.drop_table("truelayer_enrichment_jobs", cascade=True)
    #     op.drop_index("idx_merchant_norm_pattern", table_name="merchant_normalizations")
    #     op.drop_index("idx_merchant_norm_priority", table_name="merchant_normalizations")
    #     op.drop_table("merchant_normalizations", cascade=True)
    #     op.drop_index(
    #         "idx_normalized_subcategories_category", table_name="normalized_subcategories"
    #     )
    #     op.drop_index(
    #         "idx_normalized_subcategories_name", table_name="normalized_subcategories"
    #     )
    #     op.drop_table("normalized_subcategories", cascade=True)
    #     op.drop_index("idx_connection_logs_connection_id", table_name="connection_logs")
    #     op.drop_index("idx_connection_logs_created_at", table_name="connection_logs")
    #     op.drop_table("connection_logs", cascade=True)
    #     op.drop_index(
    #         "idx_truelayer_card_balance_snapshots_card",
    #         table_name="truelayer_card_balance_snapshots",
    #     )
    #     op.drop_table("truelayer_card_balance_snapshots", cascade=True)
    #     op.drop_index(
    #         "idx_import_progress_account_id", table_name="truelayer_import_progress"
    #     )
    #     op.drop_index("idx_import_progress_job_id", table_name="truelayer_import_progress")
    #     op.drop_index("idx_import_progress_status", table_name="truelayer_import_progress")
    #     op.drop_table("truelayer_import_progress", cascade=True)
    #     op.drop_index("idx_user_sessions_expires_at", table_name="user_sessions")
    #     op.drop_index("idx_user_sessions_user_id", table_name="user_sessions")
    #     op.drop_table("user_sessions", cascade=True)
    #     op.drop_index("idx_truelayer_cards_connection", table_name="truelayer_cards")
    #     op.drop_table("truelayer_cards", cascade=True)
    #     op.drop_index("idx_errors_connection", table_name="gmail_processing_errors")
    #     op.drop_index("idx_errors_job", table_name="gmail_processing_errors")
    #     op.drop_index("idx_errors_occurred", table_name="gmail_processing_errors")
    #     op.drop_index("idx_errors_stage", table_name="gmail_processing_errors")
    #     op.drop_index("idx_errors_type", table_name="gmail_processing_errors")
    #     op.drop_table("gmail_processing_errors", cascade=True)
    #     op.drop_index("idx_gmail_matches_receipt", table_name="gmail_transaction_matches")
    #     op.drop_index(
    #         "idx_gmail_matches_transaction", table_name="gmail_transaction_matches"
    #     )
    #     op.drop_index(
    #         "idx_gmail_matches_unconfirmed",
    #         table_name="gmail_transaction_matches",
    #         postgresql_where="((match_confidence < 80) AND (user_confirmed = false))",
    #     )
    #     op.drop_table("gmail_transaction_matches", cascade=True)
    #     op.drop_index("idx_category_rules_category_id", table_name="category_rules")
    #     op.drop_index("idx_category_rules_pattern", table_name="category_rules")
    #     op.drop_index("idx_category_rules_priority", table_name="category_rules")
    #     op.drop_index("idx_category_rules_subcategory_id", table_name="category_rules")
    #     op.drop_index("idx_category_rules_type", table_name="category_rules")
    #     op.drop_table("category_rules", cascade=True)
    #     op.drop_index("idx_webhook_events_event_id", table_name="webhook_events")
    #     op.drop_index(
    #         "idx_webhook_events_unprocessed",
    #         table_name="webhook_events",
    #         postgresql_where="(processed = false)",
    #     )
    #     op.drop_table("webhook_events", cascade=True)
    #     op.drop_index(
    #         "idx_truelayer_card_transactions_card", table_name="truelayer_card_transactions"
    #     )
    #     op.drop_index(
    #         "idx_truelayer_card_transactions_timestamp",
    #         table_name="truelayer_card_transactions",
    #     )
    #     op.drop_table("truelayer_card_transactions", cascade=True)
    #     op.drop_index(
    #         "idx_gmail_sender_patterns_active",
    #         table_name="gmail_sender_patterns",
    #         postgresql_where="(is_active = true)",
    #     )
    #     op.drop_index(
    #         "idx_gmail_sender_patterns_domain", table_name="gmail_sender_patterns"
    #     )
    #     op.drop_table("gmail_sender_patterns", cascade=True)
    #     op.drop_index("idx_import_jobs_connection_id", table_name="truelayer_import_jobs")
    #     op.drop_index("idx_import_jobs_created_at", table_name="truelayer_import_jobs")
    #     op.drop_index("idx_import_jobs_status", table_name="truelayer_import_jobs")
    #     op.drop_index("idx_import_jobs_user_id", table_name="truelayer_import_jobs")
    #     op.drop_table("truelayer_import_jobs", cascade=True)
    #     op.drop_index(
    #         "idx_merchant_stats_connection", table_name="gmail_merchant_statistics"
    #     )
    #     op.drop_index("idx_merchant_stats_merchant", table_name="gmail_merchant_statistics")
    #     op.drop_index("idx_merchant_stats_method", table_name="gmail_merchant_statistics")
    #     op.drop_index("idx_merchant_stats_period", table_name="gmail_merchant_statistics")
    #     op.drop_table("gmail_merchant_statistics", cascade=True)
    #     op.drop_index("idx_security_audit_event_type", table_name="security_audit_log")
    #     op.drop_index("idx_security_audit_ip", table_name="security_audit_log")
    #     op.drop_index("idx_security_audit_timestamp", table_name="security_audit_log")
    #     op.drop_index("idx_security_audit_user_id", table_name="security_audit_log")
    #     op.drop_table("security_audit_log", cascade=True)
    #     op.drop_index("idx_gmail_sync_jobs_connection", table_name="gmail_sync_jobs")
    #     op.drop_index(
    #         "idx_gmail_sync_jobs_status",
    #         table_name="gmail_sync_jobs",
    #         postgresql_where="((status)::text = ANY ((ARRAY['queued'::character varying, 'running'::character varying])::text[]))",
    #     )
    #     op.drop_table("gmail_sync_jobs", cascade=True)
    #     op.drop_index("idx_oauth_state_state", table_name="oauth_state")
    #     op.drop_table("oauth_state", cascade=True)
    #     op.drop_table("_backup_lookup_description", cascade=True)
    #     op.drop_index("idx_custom_categories_type", table_name="custom_categories")
    #     op.drop_index("idx_custom_categories_user", table_name="custom_categories")
    #     op.drop_table("custom_categories", cascade=True)
    #     op.drop_index(
    #         "idx_gmail_merchant_aliases_bank", table_name="gmail_merchant_aliases"
    #     )
    #     op.drop_index(
    #         "idx_gmail_merchant_aliases_receipt", table_name="gmail_merchant_aliases"
    #     )
    #     op.drop_table("gmail_merchant_aliases", cascade=True)
    #     op.drop_table("llm_models", cascade=True)
    op.alter_column(
        "amazon_business_connections",
        "user_id",
        existing_type=sa.INTEGER(),
        server_default=None,
        existing_nullable=True,
    )
    op.alter_column(
        "amazon_business_connections",
        "region",
        existing_type=sa.VARCHAR(length=10),
        server_default=None,
        existing_nullable=True,
    )
    op.drop_column("amazon_business_connections", "is_sandbox")
    op.drop_column("amazon_business_connections", "last_synced_at")
    op.drop_column("amazon_business_connections", "marketplace_id")
    op.drop_index("idx_ab_line_items_asin", table_name="amazon_business_line_items")
    op.drop_index("idx_ab_line_items_order", table_name="amazon_business_line_items")
    op.create_index(
        "idx_amazon_business_line_items_asin",
        "amazon_business_line_items",
        ["asin"],
        unique=False,
    )
    op.create_index(
        "idx_amazon_business_line_items_order_id",
        "amazon_business_line_items",
        ["order_id"],
        unique=False,
    )
    op.alter_column(
        "amazon_business_orders",
        "currency",
        existing_type=sa.VARCHAR(length=10),
        server_default=None,
        existing_nullable=True,
    )
    op.alter_column(
        "amazon_business_orders",
        "item_count",
        existing_type=sa.INTEGER(),
        server_default=None,
        existing_nullable=True,
    )
    op.drop_index("idx_ab_orders_date", table_name="amazon_business_orders")
    op.drop_index("idx_ab_orders_net_total", table_name="amazon_business_orders")
    op.drop_index("idx_ab_orders_order_id", table_name="amazon_business_orders")
    op.create_index(
        "idx_amazon_business_orders_date",
        "amazon_business_orders",
        ["order_date"],
        unique=False,
    )
    op.create_index(
        "idx_amazon_business_orders_net_total",
        "amazon_business_orders",
        ["net_total"],
        unique=False,
    )
    op.alter_column(
        "amazon_orders",
        "order_id",
        existing_type=sa.VARCHAR(length=100),
        type_=sa.String(length=50),
        existing_nullable=False,
    )
    op.alter_column(
        "amazon_orders",
        "website",
        existing_type=sa.VARCHAR(length=100),
        type_=sa.String(length=50),
        existing_nullable=False,
    )
    op.alter_column(
        "amazon_orders",
        "currency",
        existing_type=sa.VARCHAR(length=3),
        type_=sa.String(length=10),
        existing_nullable=False,
    )
    op.drop_index("idx_amazon_orders_date", table_name="amazon_orders")
    op.drop_index("idx_amazon_orders_website", table_name="amazon_orders")
    op.alter_column(
        "amazon_returns",
        "order_id",
        existing_type=sa.VARCHAR(length=100),
        type_=sa.String(length=50),
        existing_nullable=False,
    )
    op.alter_column(
        "amazon_returns",
        "reversal_id",
        existing_type=sa.VARCHAR(length=100),
        type_=sa.String(length=50),
        existing_nullable=False,
    )
    op.alter_column(
        "amazon_returns",
        "currency",
        existing_type=sa.VARCHAR(length=3),
        type_=sa.String(length=10),
        existing_nullable=False,
    )
    op.alter_column(
        "amazon_returns",
        "original_transaction_id",
        existing_type=sa.INTEGER(),
        comment=None,
        existing_comment="Transaction ID (legacy only - TrueLayer returns update descriptions instead)",
        existing_nullable=True,
    )
    op.alter_column(
        "amazon_returns",
        "refund_transaction_id",
        existing_type=sa.INTEGER(),
        comment=None,
        existing_comment="Refund transaction ID (legacy only - TrueLayer returns update descriptions instead)",
        existing_nullable=True,
    )
    op.drop_constraint(
        "amazon_returns_reversal_id_key", "amazon_returns", type_="unique"
    )
    op.create_index(
        "idx_amazon_returns_original_txn",
        "amazon_returns",
        ["original_transaction_id"],
        unique=False,
    )
    op.create_index(
        "idx_amazon_returns_refund_txn",
        "amazon_returns",
        ["refund_transaction_id"],
        unique=False,
    )
    op.alter_column(
        "apple_transactions",
        "item_count",
        existing_type=sa.INTEGER(),
        server_default=None,
        existing_nullable=True,
    )
    op.alter_column(
        "bank_connections",
        "access_token",
        existing_type=sa.TEXT(),
        comment=None,
        existing_comment="Encrypted OAuth access token (1-hour lifetime)",
        existing_nullable=True,
    )
    op.alter_column(
        "bank_connections",
        "refresh_token",
        existing_type=sa.TEXT(),
        comment=None,
        existing_comment="Encrypted OAuth refresh token (90-day lifetime)",
        existing_nullable=True,
    )
    op.alter_column(
        "bank_connections",
        "connection_status",
        existing_type=sa.VARCHAR(length=30),
        server_default="active",
        existing_nullable=True,
    )
    op.drop_constraint(
        "bank_connections_user_id_provider_id_key", "bank_connections", type_="unique"
    )
    op.drop_index("idx_bank_connections_status", table_name="bank_connections")
    op.drop_index("idx_bank_connections_user_status", table_name="bank_connections")
    op.drop_constraint(
        "bank_connections_user_id_fkey", "bank_connections", type_="foreignkey"
    )
    op.create_foreign_key(None, "bank_connections", "users", ["user_id"], ["id"])
    op.drop_table_comment(
        "bank_connections",
        existing_comment="OAuth connections to banks via TrueLayer",
        schema=None,
    )
    op.alter_column(
        "categories",
        "ai_suggested",
        existing_type=sa.BOOLEAN(),
        server_default="false",
        existing_nullable=False,
    )
    op.alter_column(
        "gmail_connections",
        "user_id",
        existing_type=sa.INTEGER(),
        server_default=None,
        existing_nullable=False,
    )
    op.alter_column(
        "gmail_connections",
        "encryption_version",
        existing_type=sa.INTEGER(),
        server_default=None,
        existing_nullable=True,
    )
    op.drop_constraint(
        "gmail_connections_user_email_unique", "gmail_connections", type_="unique"
    )
    op.drop_index("idx_gmail_connections_status", table_name="gmail_connections")
    op.drop_index("idx_gmail_connections_user", table_name="gmail_connections")
    op.create_unique_constraint(
        "uq_gmail_conn_user_email", "gmail_connections", ["user_id", "email_address"]
    )
    op.drop_table_comment(
        "gmail_email_content",
        existing_comment="Stores full email content for development/debugging of receipt parsers",
        schema=None,
    )
    op.alter_column(
        "gmail_receipts",
        "currency_code",
        existing_type=sa.VARCHAR(length=3),
        server_default=None,
        existing_nullable=True,
    )
    op.alter_column(
        "gmail_receipts",
        "parse_method",
        existing_type=sa.VARCHAR(length=50),
        type_=sa.String(length=30),
        existing_nullable=True,
    )
    op.alter_column(
        "gmail_receipts",
        "llm_parse_status",
        existing_type=sa.VARCHAR(length=20),
        server_default=None,
        comment=None,
        existing_comment="LLM parsing queue status: NULL (not queued), pending, processing, completed, failed",
        existing_nullable=True,
    )
    op.alter_column(
        "gmail_receipts",
        "llm_estimated_cost_cents",
        existing_type=sa.INTEGER(),
        comment=None,
        existing_comment="Estimated cost in cents before LLM parsing",
        existing_nullable=True,
    )
    op.alter_column(
        "gmail_receipts",
        "llm_actual_cost_cents",
        existing_type=sa.INTEGER(),
        comment=None,
        existing_comment="Actual cost in cents after LLM parsing",
        existing_nullable=True,
    )
    op.alter_column(
        "gmail_receipts",
        "llm_parsed_at",
        existing_type=postgresql.TIMESTAMP(timezone=True),
        comment=None,
        existing_comment="Timestamp when LLM parsing completed",
        existing_nullable=True,
    )
    op.drop_index("idx_gmail_receipts_hash", table_name="gmail_receipts")
    op.drop_index(
        "idx_gmail_receipts_llm_queue",
        table_name="gmail_receipts",
        postgresql_where="(llm_parse_status IS NOT NULL)",
    )
    op.drop_index(
        "idx_gmail_receipts_parsed",
        table_name="gmail_receipts",
        postgresql_where="((parsing_status)::text = 'parsed'::text)",
    )
    op.drop_index(
        "idx_gmail_receipts_pdf_status",
        table_name="gmail_receipts",
        postgresql_where="((pdf_processing_status)::text = ANY ((ARRAY['pending'::character varying, 'processing'::character varying])::text[]))",
    )
    op.drop_index(
        "idx_gmail_receipts_pending",
        table_name="gmail_receipts",
        postgresql_where="((parsing_status)::text = 'pending'::text)",
    )
    op.drop_index(
        "idx_gmail_receipts_unparseable",
        table_name="gmail_receipts",
        postgresql_where="((parsing_status)::text = 'unparseable'::text)",
    )
    op.drop_constraint(
        "gmail_receipts_duplicate_of_id_fkey", "gmail_receipts", type_="foreignkey"
    )
    op.drop_column("gmail_receipts", "is_purchase")
    op.drop_column("gmail_receipts", "pdf_last_error")
    op.drop_column("gmail_receipts", "pdf_retry_count")
    op.drop_column("gmail_receipts", "pdf_processing_status")
    op.drop_column("gmail_receipts", "duplicate_of_id")
    op.drop_column("gmail_receipts", "is_duplicate")
    op.alter_column(
        "pdf_attachments",
        "bucket_name",
        existing_type=sa.VARCHAR(length=100),
        server_default=None,
        existing_nullable=True,
    )
    op.alter_column(
        "pdf_attachments",
        "object_key",
        existing_type=sa.VARCHAR(length=500),
        comment=None,
        existing_comment="S3 object key in format: receipts/YYYY/MM/DD/{message_id}/{filename}",
        existing_nullable=False,
    )
    op.alter_column(
        "pdf_attachments",
        "content_hash",
        existing_type=sa.VARCHAR(length=64),
        comment=None,
        existing_comment="SHA256 hash of PDF content for deduplication",
        existing_nullable=False,
    )
    op.drop_index("idx_pdf_attachments_unique", table_name="pdf_attachments")
    op.create_unique_constraint(
        "uq_pdf_message_filename", "pdf_attachments", ["message_id", "filename"]
    )
    op.drop_table_comment(
        "pdf_attachments",
        existing_comment="PDF attachments stored in MinIO object storage",
        schema=None,
    )
    op.drop_index("idx_truelayer_accounts_account_id", table_name="truelayer_accounts")
    op.drop_index(
        "idx_truelayer_accounts_account_number_gin",
        table_name="truelayer_accounts",
        postgresql_using="gin",
    )
    op.drop_index(
        "idx_truelayer_accounts_connection_id", table_name="truelayer_accounts"
    )
    op.drop_index("idx_truelayer_accounts_last_synced", table_name="truelayer_accounts")
    op.drop_constraint(
        "truelayer_accounts_connection_id_account_id_unique",
        "truelayer_accounts",
        type_="unique",
    )
    op.drop_constraint(
        "truelayer_accounts_connection_id_fkey",
        "truelayer_accounts",
        type_="foreignkey",
    )
    op.create_foreign_key(
        None, "truelayer_accounts", "bank_connections", ["connection_id"], ["id"]
    )
    op.drop_column("truelayer_accounts", "last_synced_at_incremental")
    op.drop_index(
        "idx_truelayer_amazon_matches_order",
        table_name="truelayer_amazon_transaction_matches",
    )
    op.drop_index(
        "idx_truelayer_amazon_matches_transaction",
        table_name="truelayer_amazon_transaction_matches",
    )
    op.create_index(
        "idx_truelayer_amazon_matches_amazon_order",
        "truelayer_amazon_transaction_matches",
        ["amazon_order_id"],
        unique=False,
    )
    op.create_index(
        "idx_truelayer_amazon_matches_truelayer_txn",
        "truelayer_amazon_transaction_matches",
        ["truelayer_transaction_id"],
        unique=False,
    )
    op.drop_constraint(
        "truelayer_amazon_matches_order_fk",
        "truelayer_amazon_transaction_matches",
        type_="foreignkey",
    )
    op.drop_constraint(
        "truelayer_amazon_matches_transaction_fk",
        "truelayer_amazon_transaction_matches",
        type_="foreignkey",
    )
    op.create_foreign_key(
        None,
        "truelayer_amazon_transaction_matches",
        "amazon_orders",
        ["amazon_order_id"],
        ["id"],
    )
    op.create_foreign_key(
        None,
        "truelayer_amazon_transaction_matches",
        "truelayer_transactions",
        ["truelayer_transaction_id"],
        ["id"],
    )
    op.drop_table_comment(
        "truelayer_apple_transaction_matches",
        existing_comment="Links TrueLayer bank transactions to Apple Store purchases for enrichment",
        schema=None,
    )
    op.drop_index("idx_truelayer_balances_snapshot_at", table_name="truelayer_balances")
    op.drop_constraint(
        "truelayer_balances_account_id_fkey", "truelayer_balances", type_="foreignkey"
    )
    op.create_foreign_key(
        None, "truelayer_balances", "truelayer_accounts", ["account_id"], ["id"]
    )
    op.alter_column(
        "truelayer_transactions",
        "normalised_provider_transaction_id",
        existing_type=sa.VARCHAR(length=255),
        comment=None,
        existing_comment="Recommended unique ID for transaction identification across API calls",
        existing_nullable=False,
    )
    op.alter_column(
        "truelayer_transactions",
        "pre_enrichment_status",
        existing_type=sa.VARCHAR(length=20),
        comment=None,
        existing_comment="Pre-enrichment matching status: None (not matchable), Matched (already matched), Apple (unmatched Apple), AMZN (unmatched Amazon), AMZN RTN (unmatched Amazon return)",
        existing_nullable=True,
        existing_server_default=sa.text("'None'::character varying"),
    )
    op.drop_index(
        "idx_truelayer_enrichment_required",
        table_name="truelayer_transactions",
        postgresql_where="(enrichment_required = true)",
    )
    op.drop_index(
        "idx_truelayer_transactions_account_id", table_name="truelayer_transactions"
    )
    op.drop_index(
        "idx_truelayer_transactions_category", table_name="truelayer_transactions"
    )
    op.drop_index(
        "idx_truelayer_transactions_category_id", table_name="truelayer_transactions"
    )
    op.drop_index(
        "idx_truelayer_transactions_import_job", table_name="truelayer_transactions"
    )
    op.drop_index(
        "idx_truelayer_transactions_merchant", table_name="truelayer_transactions"
    )
    op.drop_index(
        "idx_truelayer_transactions_metadata_gin",
        table_name="truelayer_transactions",
        postgresql_using="gin",
    )
    op.drop_index(
        "idx_truelayer_transactions_pre_enrichment_status",
        table_name="truelayer_transactions",
    )
    op.drop_index(
        "idx_truelayer_transactions_subcategory_id", table_name="truelayer_transactions"
    )
    op.drop_index(
        "idx_truelayer_transactions_timestamp", table_name="truelayer_transactions"
    )
    op.create_index(
        "idx_truelayer_txn_account",
        "truelayer_transactions",
        ["account_id"],
        unique=False,
    )
    op.create_index(
        "idx_truelayer_txn_normalised_id",
        "truelayer_transactions",
        ["normalised_provider_transaction_id"],
        unique=True,
    )
    op.create_index(
        "idx_truelayer_txn_timestamp",
        "truelayer_transactions",
        ["timestamp"],
        unique=False,
    )
    op.drop_constraint(
        "truelayer_transactions_subcategory_id_fkey",
        "truelayer_transactions",
        type_="foreignkey",
    )
    op.drop_constraint(
        "truelayer_transactions_account_id_fkey",
        "truelayer_transactions",
        type_="foreignkey",
    )
    op.drop_constraint(
        "truelayer_transactions_import_job_id_fkey",
        "truelayer_transactions",
        type_="foreignkey",
    )
    op.drop_constraint(
        "truelayer_transactions_category_id_fkey",
        "truelayer_transactions",
        type_="foreignkey",
    )
    op.create_foreign_key(
        None, "truelayer_transactions", "truelayer_accounts", ["account_id"], ["id"]
    )
    op.drop_table_comment(
        "truelayer_transactions",
        existing_comment="Transactions synced from TrueLayer Data API",
        schema=None,
    )
    op.drop_column("truelayer_transactions", "subcategory_id")
    op.drop_column("truelayer_transactions", "category_id")
    op.drop_column("truelayer_transactions", "import_job_id")
    op.drop_column("truelayer_transactions", "enrichment_required")
    op.alter_column(
        "users",
        "username",
        existing_type=sa.VARCHAR(length=100),
        comment=None,
        existing_comment="Unique username for login",
        existing_nullable=True,
    )
    op.alter_column(
        "users",
        "password_hash",
        existing_type=sa.VARCHAR(length=255),
        comment=None,
        existing_comment="Hashed password using pbkdf2:sha256:600000",
        existing_nullable=True,
    )
    op.alter_column(
        "users",
        "is_admin",
        existing_type=sa.BOOLEAN(),
        comment=None,
        existing_comment="Admin users have full system access",
        existing_nullable=False,
        existing_server_default=sa.text("false"),
    )
    op.alter_column(
        "users",
        "is_active",
        existing_type=sa.BOOLEAN(),
        comment=None,
        existing_comment="Inactive users cannot log in",
        existing_nullable=False,
        existing_server_default=sa.text("true"),
    )
    op.alter_column(
        "users",
        "last_login_at",
        existing_type=postgresql.TIMESTAMP(),
        comment=None,
        existing_comment="Timestamp of last successful login",
        existing_nullable=True,
    )
    op.drop_index("idx_users_email", table_name="users")
    op.drop_index("idx_users_username", table_name="users")
    op.drop_table_comment(
        "users",
        existing_comment="User accounts for authentication and data access control",
        schema=None,
    )
    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table_comment(
        "users",
        "User accounts for authentication and data access control",
        existing_comment=None,
        schema=None,
    )
    op.create_index("idx_users_username", "users", ["username"], unique=False)
    op.create_index("idx_users_email", "users", ["email"], unique=False)
    op.alter_column(
        "users",
        "last_login_at",
        existing_type=postgresql.TIMESTAMP(),
        comment="Timestamp of last successful login",
        existing_nullable=True,
    )
    op.alter_column(
        "users",
        "is_active",
        existing_type=sa.BOOLEAN(),
        comment="Inactive users cannot log in",
        existing_nullable=False,
        existing_server_default=sa.text("true"),
    )
    op.alter_column(
        "users",
        "is_admin",
        existing_type=sa.BOOLEAN(),
        comment="Admin users have full system access",
        existing_nullable=False,
        existing_server_default=sa.text("false"),
    )
    op.alter_column(
        "users",
        "password_hash",
        existing_type=sa.VARCHAR(length=255),
        comment="Hashed password using pbkdf2:sha256:600000",
        existing_nullable=True,
    )
    op.alter_column(
        "users",
        "username",
        existing_type=sa.VARCHAR(length=100),
        comment="Unique username for login",
        existing_nullable=True,
    )
    op.add_column(
        "truelayer_transactions",
        sa.Column(
            "enrichment_required",
            sa.BOOLEAN(),
            server_default=sa.text("true"),
            autoincrement=False,
            nullable=True,
        ),
    )
    op.add_column(
        "truelayer_transactions",
        sa.Column("import_job_id", sa.INTEGER(), autoincrement=False, nullable=True),
    )
    op.add_column(
        "truelayer_transactions",
        sa.Column("category_id", sa.INTEGER(), autoincrement=False, nullable=True),
    )
    op.add_column(
        "truelayer_transactions",
        sa.Column("subcategory_id", sa.INTEGER(), autoincrement=False, nullable=True),
    )
    op.create_table_comment(
        "truelayer_transactions",
        "Transactions synced from TrueLayer Data API",
        existing_comment=None,
        schema=None,
    )
    op.drop_constraint(None, "truelayer_transactions", type_="foreignkey")
    op.create_foreign_key(
        "truelayer_transactions_category_id_fkey",
        "truelayer_transactions",
        "normalized_categories",
        ["category_id"],
        ["id"],
    )
    op.create_foreign_key(
        "truelayer_transactions_import_job_id_fkey",
        "truelayer_transactions",
        "truelayer_import_jobs",
        ["import_job_id"],
        ["id"],
        ondelete="SET NULL",
    )
    op.create_foreign_key(
        "truelayer_transactions_account_id_fkey",
        "truelayer_transactions",
        "truelayer_accounts",
        ["account_id"],
        ["id"],
        ondelete="CASCADE",
    )
    op.create_foreign_key(
        "truelayer_transactions_subcategory_id_fkey",
        "truelayer_transactions",
        "normalized_subcategories",
        ["subcategory_id"],
        ["id"],
    )
    op.drop_index("idx_truelayer_txn_timestamp", table_name="truelayer_transactions")
    op.drop_index(
        "idx_truelayer_txn_normalised_id", table_name="truelayer_transactions"
    )
    op.drop_index("idx_truelayer_txn_account", table_name="truelayer_transactions")
    op.create_index(
        "idx_truelayer_transactions_timestamp",
        "truelayer_transactions",
        ["timestamp"],
        unique=False,
    )
    op.create_index(
        "idx_truelayer_transactions_subcategory_id",
        "truelayer_transactions",
        ["subcategory_id"],
        unique=False,
    )
    op.create_index(
        "idx_truelayer_transactions_pre_enrichment_status",
        "truelayer_transactions",
        ["pre_enrichment_status"],
        unique=False,
    )
    op.create_index(
        "idx_truelayer_transactions_metadata_gin",
        "truelayer_transactions",
        ["metadata"],
        unique=False,
        postgresql_using="gin",
    )
    op.create_index(
        "idx_truelayer_transactions_merchant",
        "truelayer_transactions",
        ["merchant_name"],
        unique=False,
    )
    op.create_index(
        "idx_truelayer_transactions_import_job",
        "truelayer_transactions",
        ["import_job_id"],
        unique=False,
    )
    op.create_index(
        "idx_truelayer_transactions_category_id",
        "truelayer_transactions",
        ["category_id"],
        unique=False,
    )
    op.create_index(
        "idx_truelayer_transactions_category",
        "truelayer_transactions",
        ["transaction_category"],
        unique=False,
    )
    op.create_index(
        "idx_truelayer_transactions_account_id",
        "truelayer_transactions",
        ["account_id"],
        unique=False,
    )
    op.create_index(
        "idx_truelayer_enrichment_required",
        "truelayer_transactions",
        ["enrichment_required"],
        unique=False,
        postgresql_where="(enrichment_required = true)",
    )
    op.alter_column(
        "truelayer_transactions",
        "pre_enrichment_status",
        existing_type=sa.VARCHAR(length=20),
        comment="Pre-enrichment matching status: None (not matchable), Matched (already matched), Apple (unmatched Apple), AMZN (unmatched Amazon), AMZN RTN (unmatched Amazon return)",
        existing_nullable=True,
        existing_server_default=sa.text("'None'::character varying"),
    )
    op.alter_column(
        "truelayer_transactions",
        "normalised_provider_transaction_id",
        existing_type=sa.VARCHAR(length=255),
        comment="Recommended unique ID for transaction identification across API calls",
        existing_nullable=False,
    )
    op.drop_constraint(None, "truelayer_balances", type_="foreignkey")
    op.create_foreign_key(
        "truelayer_balances_account_id_fkey",
        "truelayer_balances",
        "truelayer_accounts",
        ["account_id"],
        ["id"],
        ondelete="CASCADE",
    )
    op.create_index(
        "idx_truelayer_balances_snapshot_at",
        "truelayer_balances",
        ["snapshot_at"],
        unique=False,
    )
    op.create_table_comment(
        "truelayer_apple_transaction_matches",
        "Links TrueLayer bank transactions to Apple Store purchases for enrichment",
        existing_comment=None,
        schema=None,
    )
    op.drop_constraint(None, "truelayer_amazon_transaction_matches", type_="foreignkey")
    op.drop_constraint(None, "truelayer_amazon_transaction_matches", type_="foreignkey")
    op.create_foreign_key(
        "truelayer_amazon_matches_transaction_fk",
        "truelayer_amazon_transaction_matches",
        "truelayer_transactions",
        ["truelayer_transaction_id"],
        ["id"],
        ondelete="CASCADE",
    )
    op.create_foreign_key(
        "truelayer_amazon_matches_order_fk",
        "truelayer_amazon_transaction_matches",
        "amazon_orders",
        ["amazon_order_id"],
        ["id"],
        ondelete="CASCADE",
    )
    op.drop_index(
        "idx_truelayer_amazon_matches_truelayer_txn",
        table_name="truelayer_amazon_transaction_matches",
    )
    op.drop_index(
        "idx_truelayer_amazon_matches_amazon_order",
        table_name="truelayer_amazon_transaction_matches",
    )
    op.create_index(
        "idx_truelayer_amazon_matches_transaction",
        "truelayer_amazon_transaction_matches",
        ["truelayer_transaction_id"],
        unique=False,
    )
    op.create_index(
        "idx_truelayer_amazon_matches_order",
        "truelayer_amazon_transaction_matches",
        ["amazon_order_id"],
        unique=False,
    )
    op.add_column(
        "truelayer_accounts",
        sa.Column(
            "last_synced_at_incremental",
            postgresql.TIMESTAMP(timezone=True),
            autoincrement=False,
            nullable=True,
        ),
    )
    op.drop_constraint(None, "truelayer_accounts", type_="foreignkey")
    op.create_foreign_key(
        "truelayer_accounts_connection_id_fkey",
        "truelayer_accounts",
        "bank_connections",
        ["connection_id"],
        ["id"],
        ondelete="CASCADE",
    )
    op.create_unique_constraint(
        "truelayer_accounts_connection_id_account_id_unique",
        "truelayer_accounts",
        ["connection_id", "account_id"],
        postgresql_nulls_not_distinct=False,
    )
    op.create_index(
        "idx_truelayer_accounts_last_synced",
        "truelayer_accounts",
        ["last_synced_at_incremental"],
        unique=False,
    )
    op.create_index(
        "idx_truelayer_accounts_connection_id",
        "truelayer_accounts",
        ["connection_id"],
        unique=False,
    )
    op.create_index(
        "idx_truelayer_accounts_account_number_gin",
        "truelayer_accounts",
        ["account_number_json"],
        unique=False,
        postgresql_using="gin",
    )
    op.create_index(
        "idx_truelayer_accounts_account_id",
        "truelayer_accounts",
        ["account_id"],
        unique=False,
    )
    op.create_table_comment(
        "pdf_attachments",
        "PDF attachments stored in MinIO object storage",
        existing_comment=None,
        schema=None,
    )
    op.drop_constraint("uq_pdf_message_filename", "pdf_attachments", type_="unique")
    op.create_index(
        "idx_pdf_attachments_unique",
        "pdf_attachments",
        ["message_id", "filename"],
        unique=True,
    )
    op.alter_column(
        "pdf_attachments",
        "content_hash",
        existing_type=sa.VARCHAR(length=64),
        comment="SHA256 hash of PDF content for deduplication",
        existing_nullable=False,
    )
    op.alter_column(
        "pdf_attachments",
        "object_key",
        existing_type=sa.VARCHAR(length=500),
        comment="S3 object key in format: receipts/YYYY/MM/DD/{message_id}/{filename}",
        existing_nullable=False,
    )
    op.alter_column(
        "pdf_attachments",
        "bucket_name",
        existing_type=sa.VARCHAR(length=100),
        server_default=sa.text("'receipts'::character varying"),
        existing_nullable=True,
    )
    op.add_column(
        "gmail_receipts",
        sa.Column(
            "is_duplicate",
            sa.BOOLEAN(),
            server_default=sa.text("false"),
            autoincrement=False,
            nullable=True,
        ),
    )
    op.add_column(
        "gmail_receipts",
        sa.Column("duplicate_of_id", sa.INTEGER(), autoincrement=False, nullable=True),
    )
    op.add_column(
        "gmail_receipts",
        sa.Column(
            "pdf_processing_status",
            sa.VARCHAR(length=20),
            server_default=sa.text("'none'::character varying"),
            autoincrement=False,
            nullable=True,
            comment="Status of async PDF processing: none (no PDF), pending (queued), processing (in progress), completed (done), failed (error)",
        ),
    )
    op.add_column(
        "gmail_receipts",
        sa.Column(
            "pdf_retry_count",
            sa.INTEGER(),
            server_default=sa.text("0"),
            autoincrement=False,
            nullable=True,
            comment="Number of times PDF processing has been retried (for error tracking)",
        ),
    )
    op.add_column(
        "gmail_receipts",
        sa.Column(
            "pdf_last_error",
            sa.TEXT(),
            autoincrement=False,
            nullable=True,
            comment="Last error message from PDF processing (if failed)",
        ),
    )
    op.add_column(
        "gmail_receipts",
        sa.Column(
            "is_purchase",
            sa.BOOLEAN(),
            server_default=sa.text("true"),
            autoincrement=False,
            nullable=True,
        ),
    )
    op.create_foreign_key(
        "gmail_receipts_duplicate_of_id_fkey",
        "gmail_receipts",
        "gmail_receipts",
        ["duplicate_of_id"],
        ["id"],
    )
    op.create_index(
        "idx_gmail_receipts_unparseable",
        "gmail_receipts",
        ["parsing_status"],
        unique=False,
        postgresql_where="((parsing_status)::text = 'unparseable'::text)",
    )
    op.create_index(
        "idx_gmail_receipts_pending",
        "gmail_receipts",
        ["parsing_status"],
        unique=False,
        postgresql_where="((parsing_status)::text = 'pending'::text)",
    )
    op.create_index(
        "idx_gmail_receipts_pdf_status",
        "gmail_receipts",
        ["pdf_processing_status"],
        unique=False,
        postgresql_where="((pdf_processing_status)::text = ANY ((ARRAY['pending'::character varying, 'processing'::character varying])::text[]))",
    )
    op.create_index(
        "idx_gmail_receipts_parsed",
        "gmail_receipts",
        ["parsing_status"],
        unique=False,
        postgresql_where="((parsing_status)::text = 'parsed'::text)",
    )
    op.create_index(
        "idx_gmail_receipts_llm_queue",
        "gmail_receipts",
        ["llm_parse_status"],
        unique=False,
        postgresql_where="(llm_parse_status IS NOT NULL)",
    )
    op.create_index(
        "idx_gmail_receipts_hash", "gmail_receipts", ["receipt_hash"], unique=False
    )
    op.alter_column(
        "gmail_receipts",
        "llm_parsed_at",
        existing_type=postgresql.TIMESTAMP(timezone=True),
        comment="Timestamp when LLM parsing completed",
        existing_nullable=True,
    )
    op.alter_column(
        "gmail_receipts",
        "llm_actual_cost_cents",
        existing_type=sa.INTEGER(),
        comment="Actual cost in cents after LLM parsing",
        existing_nullable=True,
    )
    op.alter_column(
        "gmail_receipts",
        "llm_estimated_cost_cents",
        existing_type=sa.INTEGER(),
        comment="Estimated cost in cents before LLM parsing",
        existing_nullable=True,
    )
    op.alter_column(
        "gmail_receipts",
        "llm_parse_status",
        existing_type=sa.VARCHAR(length=20),
        server_default=sa.text("NULL::character varying"),
        comment="LLM parsing queue status: NULL (not queued), pending, processing, completed, failed",
        existing_nullable=True,
    )
    op.alter_column(
        "gmail_receipts",
        "parse_method",
        existing_type=sa.String(length=30),
        type_=sa.VARCHAR(length=50),
        existing_nullable=True,
    )
    op.alter_column(
        "gmail_receipts",
        "currency_code",
        existing_type=sa.VARCHAR(length=3),
        server_default=sa.text("'GBP'::character varying"),
        existing_nullable=True,
    )
    op.create_table_comment(
        "gmail_email_content",
        "Stores full email content for development/debugging of receipt parsers",
        existing_comment=None,
        schema=None,
    )
    op.drop_constraint("uq_gmail_conn_user_email", "gmail_connections", type_="unique")
    op.create_index(
        "idx_gmail_connections_user", "gmail_connections", ["user_id"], unique=False
    )
    op.create_index(
        "idx_gmail_connections_status",
        "gmail_connections",
        ["connection_status"],
        unique=False,
    )
    op.create_unique_constraint(
        "gmail_connections_user_email_unique",
        "gmail_connections",
        ["user_id", "email_address"],
        postgresql_nulls_not_distinct=False,
    )
    op.alter_column(
        "gmail_connections",
        "encryption_version",
        existing_type=sa.INTEGER(),
        server_default=sa.text("1"),
        existing_nullable=True,
    )
    op.alter_column(
        "gmail_connections",
        "user_id",
        existing_type=sa.INTEGER(),
        server_default=sa.text("1"),
        existing_nullable=False,
    )
    op.alter_column(
        "categories",
        "ai_suggested",
        existing_type=sa.BOOLEAN(),
        server_default=None,
        existing_nullable=False,
    )
    op.create_table_comment(
        "bank_connections",
        "OAuth connections to banks via TrueLayer",
        existing_comment=None,
        schema=None,
    )
    op.drop_constraint(None, "bank_connections", type_="foreignkey")
    op.create_foreign_key(
        "bank_connections_user_id_fkey",
        "bank_connections",
        "users",
        ["user_id"],
        ["id"],
        ondelete="CASCADE",
    )
    op.create_index(
        "idx_bank_connections_user_status",
        "bank_connections",
        ["user_id", "connection_status"],
        unique=False,
    )
    op.create_index(
        "idx_bank_connections_status",
        "bank_connections",
        ["connection_status"],
        unique=False,
    )
    op.create_unique_constraint(
        "bank_connections_user_id_provider_id_key",
        "bank_connections",
        ["user_id", "provider_id"],
        postgresql_nulls_not_distinct=False,
    )
    op.alter_column(
        "bank_connections",
        "connection_status",
        existing_type=sa.VARCHAR(length=30),
        server_default=sa.text("'authorization_required'::character varying"),
        existing_nullable=True,
    )
    op.alter_column(
        "bank_connections",
        "refresh_token",
        existing_type=sa.TEXT(),
        comment="Encrypted OAuth refresh token (90-day lifetime)",
        existing_nullable=True,
    )
    op.alter_column(
        "bank_connections",
        "access_token",
        existing_type=sa.TEXT(),
        comment="Encrypted OAuth access token (1-hour lifetime)",
        existing_nullable=True,
    )
    op.alter_column(
        "apple_transactions",
        "item_count",
        existing_type=sa.INTEGER(),
        server_default=sa.text("1"),
        existing_nullable=True,
    )
    op.drop_index("idx_amazon_returns_refund_txn", table_name="amazon_returns")
    op.drop_index("idx_amazon_returns_original_txn", table_name="amazon_returns")
    op.create_unique_constraint(
        "amazon_returns_reversal_id_key",
        "amazon_returns",
        ["reversal_id"],
        postgresql_nulls_not_distinct=False,
    )
    op.alter_column(
        "amazon_returns",
        "refund_transaction_id",
        existing_type=sa.INTEGER(),
        comment="Refund transaction ID (legacy only - TrueLayer returns update descriptions instead)",
        existing_nullable=True,
    )
    op.alter_column(
        "amazon_returns",
        "original_transaction_id",
        existing_type=sa.INTEGER(),
        comment="Transaction ID (legacy only - TrueLayer returns update descriptions instead)",
        existing_nullable=True,
    )
    op.alter_column(
        "amazon_returns",
        "currency",
        existing_type=sa.String(length=10),
        type_=sa.VARCHAR(length=3),
        existing_nullable=False,
    )
    op.alter_column(
        "amazon_returns",
        "reversal_id",
        existing_type=sa.String(length=50),
        type_=sa.VARCHAR(length=100),
        existing_nullable=False,
    )
    op.alter_column(
        "amazon_returns",
        "order_id",
        existing_type=sa.String(length=50),
        type_=sa.VARCHAR(length=100),
        existing_nullable=False,
    )
    op.create_index(
        "idx_amazon_orders_website", "amazon_orders", ["website"], unique=False
    )
    op.create_index(
        "idx_amazon_orders_date", "amazon_orders", ["order_date"], unique=False
    )
    op.alter_column(
        "amazon_orders",
        "currency",
        existing_type=sa.String(length=10),
        type_=sa.VARCHAR(length=3),
        existing_nullable=False,
    )
    op.alter_column(
        "amazon_orders",
        "website",
        existing_type=sa.String(length=50),
        type_=sa.VARCHAR(length=100),
        existing_nullable=False,
    )
    op.alter_column(
        "amazon_orders",
        "order_id",
        existing_type=sa.String(length=50),
        type_=sa.VARCHAR(length=100),
        existing_nullable=False,
    )
    op.drop_index(
        "idx_amazon_business_orders_net_total", table_name="amazon_business_orders"
    )
    op.drop_index(
        "idx_amazon_business_orders_date", table_name="amazon_business_orders"
    )
    op.create_index(
        "idx_ab_orders_order_id", "amazon_business_orders", ["order_id"], unique=False
    )
    op.create_index(
        "idx_ab_orders_net_total", "amazon_business_orders", ["net_total"], unique=False
    )
    op.create_index(
        "idx_ab_orders_date", "amazon_business_orders", ["order_date"], unique=False
    )
    op.alter_column(
        "amazon_business_orders",
        "item_count",
        existing_type=sa.INTEGER(),
        server_default=sa.text("1"),
        existing_nullable=True,
    )
    op.alter_column(
        "amazon_business_orders",
        "currency",
        existing_type=sa.VARCHAR(length=10),
        server_default=sa.text("'GBP'::character varying"),
        existing_nullable=True,
    )
    op.drop_index(
        "idx_amazon_business_line_items_order_id",
        table_name="amazon_business_line_items",
    )
    op.drop_index(
        "idx_amazon_business_line_items_asin", table_name="amazon_business_line_items"
    )
    op.create_index(
        "idx_ab_line_items_order",
        "amazon_business_line_items",
        ["order_id"],
        unique=False,
    )
    op.create_index(
        "idx_ab_line_items_asin", "amazon_business_line_items", ["asin"], unique=False
    )
    op.add_column(
        "amazon_business_connections",
        sa.Column(
            "marketplace_id",
            sa.VARCHAR(length=20),
            server_default=sa.text("'A1F83G8C2ARO7P'::character varying"),
            autoincrement=False,
            nullable=True,
            comment="Amazon marketplace ID (e.g., A1F83G8C2ARO7P for UK)",
        ),
    )
    op.add_column(
        "amazon_business_connections",
        sa.Column(
            "last_synced_at",
            postgresql.TIMESTAMP(timezone=True),
            autoincrement=False,
            nullable=True,
            comment="Timestamp of last successful order sync",
        ),
    )
    op.add_column(
        "amazon_business_connections",
        sa.Column(
            "is_sandbox",
            sa.BOOLEAN(),
            server_default=sa.text("true"),
            autoincrement=False,
            nullable=True,
            comment="TRUE for sandbox environment, FALSE for production",
        ),
    )
    op.alter_column(
        "amazon_business_connections",
        "region",
        existing_type=sa.VARCHAR(length=10),
        server_default=sa.text("'UK'::character varying"),
        existing_nullable=True,
    )
    op.alter_column(
        "amazon_business_connections",
        "user_id",
        existing_type=sa.INTEGER(),
        server_default=sa.text("1"),
        existing_nullable=True,
    )
    op.create_table(
        "llm_models",
        sa.Column("id", sa.INTEGER(), autoincrement=True, nullable=False),
        sa.Column(
            "provider", sa.VARCHAR(length=50), autoincrement=False, nullable=False
        ),
        sa.Column(
            "model_name", sa.VARCHAR(length=255), autoincrement=False, nullable=False
        ),
        sa.Column(
            "display_name", sa.VARCHAR(length=255), autoincrement=False, nullable=True
        ),
        sa.Column(
            "is_builtin",
            sa.BOOLEAN(),
            server_default=sa.text("true"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "is_active",
            sa.BOOLEAN(),
            server_default=sa.text("false"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(),
            server_default=sa.text("CURRENT_TIMESTAMP"),
            autoincrement=False,
            nullable=True,
        ),
        sa.PrimaryKeyConstraint("id", name="llm_models_pkey"),
        sa.UniqueConstraint(
            "provider",
            "model_name",
            name="llm_models_provider_model_name_key",
            postgresql_include=[],
            postgresql_nulls_not_distinct=False,
        ),
    )
    op.create_table(
        "gmail_merchant_aliases",
        sa.Column("id", sa.INTEGER(), autoincrement=True, nullable=False),
        sa.Column(
            "bank_name", sa.VARCHAR(length=255), autoincrement=False, nullable=False
        ),
        sa.Column(
            "receipt_name", sa.VARCHAR(length=255), autoincrement=False, nullable=False
        ),
        sa.Column(
            "normalized_name",
            sa.VARCHAR(length=255),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column(
            "is_active",
            sa.BOOLEAN(),
            server_default=sa.text("true"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "usage_count",
            sa.INTEGER(),
            server_default=sa.text("0"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(timezone=True),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=True,
        ),
        sa.PrimaryKeyConstraint("id", name="gmail_merchant_aliases_pkey"),
    )
    op.create_index(
        "idx_gmail_merchant_aliases_receipt",
        "gmail_merchant_aliases",
        [sa.literal_column("lower(receipt_name::text)")],
        unique=False,
    )
    op.create_index(
        "idx_gmail_merchant_aliases_bank",
        "gmail_merchant_aliases",
        [sa.literal_column("lower(bank_name::text)")],
        unique=False,
    )
    op.create_table(
        "custom_categories",
        sa.Column(
            "id",
            sa.INTEGER(),
            server_default=sa.text("nextval('custom_categories_id_seq'::regclass)"),
            autoincrement=True,
            nullable=False,
        ),
        sa.Column(
            "user_id",
            sa.INTEGER(),
            server_default=sa.text("1"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column("name", sa.VARCHAR(length=100), autoincrement=False, nullable=False),
        sa.Column(
            "category_type", sa.VARCHAR(length=20), autoincrement=False, nullable=False
        ),
        sa.Column(
            "display_order",
            sa.INTEGER(),
            server_default=sa.text("0"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(timezone=True),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "updated_at",
            postgresql.TIMESTAMP(timezone=True),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=True,
        ),
        sa.CheckConstraint(
            "category_type::text = ANY (ARRAY['promoted'::character varying, 'hidden'::character varying]::text[])",
            name="custom_categories_category_type_check",
        ),
        sa.PrimaryKeyConstraint("id", name="custom_categories_pkey"),
        sa.UniqueConstraint(
            "user_id",
            "name",
            name="custom_categories_user_id_name_key",
            postgresql_include=[],
            postgresql_nulls_not_distinct=False,
        ),
        postgresql_ignore_search_path=False,
    )
    op.create_index(
        "idx_custom_categories_user", "custom_categories", ["user_id"], unique=False
    )
    op.create_index(
        "idx_custom_categories_type",
        "custom_categories",
        ["category_type"],
        unique=False,
    )
    op.create_table(
        "_backup_lookup_description",
        sa.Column("id", sa.INTEGER(), autoincrement=False, nullable=True),
        sa.Column("lookup_description", sa.TEXT(), autoincrement=False, nullable=True),
    )
    op.create_table(
        "oauth_state",
        sa.Column("id", sa.INTEGER(), autoincrement=True, nullable=False),
        sa.Column("user_id", sa.INTEGER(), autoincrement=False, nullable=False),
        sa.Column("state", sa.VARCHAR(length=255), autoincrement=False, nullable=False),
        sa.Column("code_verifier", sa.TEXT(), autoincrement=False, nullable=False),
        sa.Column(
            "expires_at", postgresql.TIMESTAMP(), autoincrement=False, nullable=False
        ),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(),
            server_default=sa.text("CURRENT_TIMESTAMP"),
            autoincrement=False,
            nullable=True,
        ),
        sa.ForeignKeyConstraint(
            ["user_id"],
            ["users.id"],
            name="oauth_state_user_id_fkey",
            ondelete="CASCADE",
        ),
        sa.PrimaryKeyConstraint("id", name="oauth_state_pkey"),
        sa.UniqueConstraint(
            "state",
            name="oauth_state_state_key",
            postgresql_include=[],
            postgresql_nulls_not_distinct=False,
        ),
    )
    op.create_index("idx_oauth_state_state", "oauth_state", ["state"], unique=False)
    op.create_table(
        "gmail_sync_jobs",
        sa.Column(
            "id",
            sa.INTEGER(),
            server_default=sa.text("nextval('gmail_sync_jobs_id_seq'::regclass)"),
            autoincrement=True,
            nullable=False,
        ),
        sa.Column("connection_id", sa.INTEGER(), autoincrement=False, nullable=False),
        sa.Column(
            "status",
            sa.VARCHAR(length=20),
            server_default=sa.text("'queued'::character varying"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "job_type",
            sa.VARCHAR(length=20),
            server_default=sa.text("'full'::character varying"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "total_messages",
            sa.INTEGER(),
            server_default=sa.text("0"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "processed_messages",
            sa.INTEGER(),
            server_default=sa.text("0"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "parsed_receipts",
            sa.INTEGER(),
            server_default=sa.text("0"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "failed_messages",
            sa.INTEGER(),
            server_default=sa.text("0"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column("error_message", sa.TEXT(), autoincrement=False, nullable=True),
        sa.Column(
            "started_at",
            postgresql.TIMESTAMP(timezone=True),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "completed_at",
            postgresql.TIMESTAMP(timezone=True),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(timezone=True),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column("sync_from_date", sa.DATE(), autoincrement=False, nullable=True),
        sa.Column("sync_to_date", sa.DATE(), autoincrement=False, nullable=True),
        sa.Column(
            "stats",
            postgresql.JSONB(astext_type=sa.Text()),
            server_default=sa.text("'{}'::jsonb"),
            autoincrement=False,
            nullable=True,
            comment='Aggregated statistics JSON: {\r\n  "by_parse_method": {"vendor_amazon": {"parsed": 45, "failed": 2}},\r\n  "by_merchant": {"amazon.co.uk": {"parsed": 45, "failed": 2}},\r\n  "datapoint_extraction": {\r\n    "merchant": {"attempted": 100, "success": 95},\r\n    "amount": {"attempted": 100, "success": 88}\r\n  },\r\n  "errors": {"api_error": 3, "parse_error": 5}\r\n}',
        ),
        sa.CheckConstraint(
            "job_type::text = ANY (ARRAY['full'::character varying, 'incremental'::character varying]::text[])",
            name="gmail_sync_jobs_job_type_check",
        ),
        sa.CheckConstraint(
            "status::text = ANY (ARRAY['queued'::character varying, 'running'::character varying, 'completed'::character varying, 'failed'::character varying, 'cancelled'::character varying]::text[])",
            name="gmail_sync_jobs_status_check",
        ),
        sa.ForeignKeyConstraint(
            ["connection_id"],
            ["gmail_connections.id"],
            name="gmail_sync_jobs_connection_id_fkey",
            ondelete="CASCADE",
        ),
        sa.PrimaryKeyConstraint("id", name="gmail_sync_jobs_pkey"),
        postgresql_ignore_search_path=False,
    )
    op.create_index(
        "idx_gmail_sync_jobs_status",
        "gmail_sync_jobs",
        ["status"],
        unique=False,
        postgresql_where="((status)::text = ANY ((ARRAY['queued'::character varying, 'running'::character varying])::text[]))",
    )
    op.create_index(
        "idx_gmail_sync_jobs_connection",
        "gmail_sync_jobs",
        ["connection_id"],
        unique=False,
    )
    op.create_table(
        "security_audit_log",
        sa.Column("id", sa.INTEGER(), autoincrement=True, nullable=False),
        sa.Column("user_id", sa.INTEGER(), autoincrement=False, nullable=True),
        sa.Column(
            "event_type", sa.VARCHAR(length=50), autoincrement=False, nullable=False
        ),
        sa.Column(
            "ip_address", sa.VARCHAR(length=45), autoincrement=False, nullable=True
        ),
        sa.Column("user_agent", sa.TEXT(), autoincrement=False, nullable=True),
        sa.Column(
            "timestamp",
            postgresql.TIMESTAMP(),
            server_default=sa.text("CURRENT_TIMESTAMP"),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column(
            "metadata",
            postgresql.JSONB(astext_type=sa.Text()),
            server_default=sa.text("'{}'::jsonb"),
            autoincrement=False,
            nullable=True,
            comment="JSONB field for flexible audit data (attempted_username, blocked_reason, etc.)",
        ),
        sa.Column(
            "success",
            sa.BOOLEAN(),
            server_default=sa.text("false"),
            autoincrement=False,
            nullable=False,
        ),
        sa.ForeignKeyConstraint(
            ["user_id"], ["users.id"], name="security_audit_log_user_id_fkey"
        ),
        sa.PrimaryKeyConstraint("id", name="security_audit_log_pkey"),
        comment="Audit trail for security events (login attempts, rate limiting, etc.)",
    )
    op.create_index(
        "idx_security_audit_user_id", "security_audit_log", ["user_id"], unique=False
    )
    op.create_index(
        "idx_security_audit_timestamp",
        "security_audit_log",
        [sa.literal_column("timestamp DESC")],
        unique=False,
    )
    op.create_index(
        "idx_security_audit_ip", "security_audit_log", ["ip_address"], unique=False
    )
    op.create_index(
        "idx_security_audit_event_type",
        "security_audit_log",
        ["event_type"],
        unique=False,
    )
    op.create_table(
        "gmail_merchant_statistics",
        sa.Column("id", sa.INTEGER(), autoincrement=True, nullable=False),
        sa.Column("connection_id", sa.INTEGER(), autoincrement=False, nullable=True),
        sa.Column(
            "sender_domain", sa.VARCHAR(length=255), autoincrement=False, nullable=False
        ),
        sa.Column(
            "merchant_normalized",
            sa.VARCHAR(length=255),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "parse_method", sa.VARCHAR(length=30), autoincrement=False, nullable=True
        ),
        sa.Column("period_start", sa.DATE(), autoincrement=False, nullable=False),
        sa.Column("period_end", sa.DATE(), autoincrement=False, nullable=False),
        sa.Column(
            "total_attempts",
            sa.INTEGER(),
            server_default=sa.text("0"),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column(
            "parsed_count",
            sa.INTEGER(),
            server_default=sa.text("0"),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column(
            "failed_count",
            sa.INTEGER(),
            server_default=sa.text("0"),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column(
            "merchant_extracted_count",
            sa.INTEGER(),
            server_default=sa.text("0"),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column(
            "brand_extracted_count",
            sa.INTEGER(),
            server_default=sa.text("0"),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column(
            "amount_extracted_count",
            sa.INTEGER(),
            server_default=sa.text("0"),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column(
            "date_extracted_count",
            sa.INTEGER(),
            server_default=sa.text("0"),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column(
            "order_id_extracted_count",
            sa.INTEGER(),
            server_default=sa.text("0"),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column(
            "line_items_extracted_count",
            sa.INTEGER(),
            server_default=sa.text("0"),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column(
            "match_attempted_count",
            sa.INTEGER(),
            server_default=sa.text("0"),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column(
            "match_success_count",
            sa.INTEGER(),
            server_default=sa.text("0"),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column(
            "avg_match_confidence",
            sa.NUMERIC(precision=5, scale=2),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "avg_parse_duration_ms", sa.INTEGER(), autoincrement=False, nullable=True
        ),
        sa.Column(
            "total_llm_cost_cents",
            sa.INTEGER(),
            server_default=sa.text("0"),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column(
            "updated_at",
            postgresql.TIMESTAMP(timezone=True),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=False,
        ),
        sa.ForeignKeyConstraint(
            ["connection_id"],
            ["gmail_connections.id"],
            name="gmail_merchant_statistics_connection_id_fkey",
            ondelete="CASCADE",
        ),
        sa.PrimaryKeyConstraint("id", name="gmail_merchant_statistics_pkey"),
        sa.UniqueConstraint(
            "connection_id",
            "sender_domain",
            "merchant_normalized",
            "parse_method",
            "period_start",
            name="unique_merchant_stats",
            postgresql_include=[],
            postgresql_nulls_not_distinct=False,
        ),
    )
    op.create_index(
        "idx_merchant_stats_period",
        "gmail_merchant_statistics",
        ["period_start", "period_end"],
        unique=False,
    )
    op.create_index(
        "idx_merchant_stats_method",
        "gmail_merchant_statistics",
        ["parse_method"],
        unique=False,
    )
    op.create_index(
        "idx_merchant_stats_merchant",
        "gmail_merchant_statistics",
        ["merchant_normalized"],
        unique=False,
    )
    op.create_index(
        "idx_merchant_stats_connection",
        "gmail_merchant_statistics",
        ["connection_id"],
        unique=False,
    )
    op.create_table(
        "truelayer_import_jobs",
        sa.Column(
            "id",
            sa.INTEGER(),
            server_default=sa.text("nextval('truelayer_import_jobs_id_seq'::regclass)"),
            autoincrement=True,
            nullable=False,
        ),
        sa.Column("user_id", sa.INTEGER(), autoincrement=False, nullable=False),
        sa.Column("connection_id", sa.INTEGER(), autoincrement=False, nullable=True),
        sa.Column(
            "job_status",
            sa.VARCHAR(length=20),
            server_default=sa.text("'pending'::character varying"),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column(
            "job_type",
            sa.VARCHAR(length=20),
            server_default=sa.text("'date_range'::character varying"),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column("from_date", sa.DATE(), autoincrement=False, nullable=True),
        sa.Column("to_date", sa.DATE(), autoincrement=False, nullable=True),
        sa.Column(
            "account_ids",
            postgresql.ARRAY(sa.TEXT()),
            server_default=sa.text("ARRAY[]::text[]"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "card_ids",
            postgresql.ARRAY(sa.TEXT()),
            server_default=sa.text("ARRAY[]::text[]"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "total_accounts",
            sa.INTEGER(),
            server_default=sa.text("0"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "total_transactions_synced",
            sa.INTEGER(),
            server_default=sa.text("0"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "total_transactions_duplicates",
            sa.INTEGER(),
            server_default=sa.text("0"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "total_transactions_errors",
            sa.INTEGER(),
            server_default=sa.text("0"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "auto_enrich",
            sa.BOOLEAN(),
            server_default=sa.text("true"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "enrich_after_completion",
            sa.BOOLEAN(),
            server_default=sa.text("false"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "enrichment_job_id", sa.INTEGER(), autoincrement=False, nullable=True
        ),
        sa.Column(
            "batch_size",
            sa.INTEGER(),
            server_default=sa.text("50"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(timezone=True),
            server_default=sa.text("CURRENT_TIMESTAMP"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "started_at",
            postgresql.TIMESTAMP(timezone=True),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "completed_at",
            postgresql.TIMESTAMP(timezone=True),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "estimated_completion",
            postgresql.TIMESTAMP(timezone=True),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "metadata",
            postgresql.JSONB(astext_type=sa.Text()),
            server_default=sa.text("'{}'::jsonb"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column("error_message", sa.TEXT(), autoincrement=False, nullable=True),
        sa.CheckConstraint(
            "job_status::text = ANY (ARRAY['pending'::character varying, 'running'::character varying, 'completed'::character varying, 'failed'::character varying, 'enriching'::character varying]::text[])",
            name="valid_job_status",
        ),
        sa.CheckConstraint(
            "job_type::text = ANY (ARRAY['date_range'::character varying, 'incremental'::character varying, 'full_sync'::character varying]::text[])",
            name="valid_job_type",
        ),
        sa.CheckConstraint(
            "from_date IS NULL OR to_date IS NULL OR from_date <= to_date",
            name="valid_dates",
        ),
        sa.ForeignKeyConstraint(
            ["connection_id"],
            ["bank_connections.id"],
            name="truelayer_import_jobs_connection_id_fkey",
            ondelete="SET NULL",
        ),
        sa.ForeignKeyConstraint(
            ["enrichment_job_id"],
            ["truelayer_enrichment_jobs.id"],
            name="fk_import_jobs_enrichment_jobs",
            ondelete="SET NULL",
        ),
        sa.ForeignKeyConstraint(
            ["user_id"],
            ["users.id"],
            name="truelayer_import_jobs_user_id_fkey",
            ondelete="CASCADE",
        ),
        sa.PrimaryKeyConstraint("id", name="truelayer_import_jobs_pkey"),
        postgresql_ignore_search_path=False,
    )
    op.create_index(
        "idx_import_jobs_user_id", "truelayer_import_jobs", ["user_id"], unique=False
    )
    op.create_index(
        "idx_import_jobs_status", "truelayer_import_jobs", ["job_status"], unique=False
    )
    op.create_index(
        "idx_import_jobs_created_at",
        "truelayer_import_jobs",
        [sa.literal_column("created_at DESC")],
        unique=False,
    )
    op.create_index(
        "idx_import_jobs_connection_id",
        "truelayer_import_jobs",
        ["connection_id"],
        unique=False,
    )
    op.create_table(
        "gmail_sender_patterns",
        sa.Column("id", sa.INTEGER(), autoincrement=True, nullable=False),
        sa.Column(
            "sender_domain", sa.VARCHAR(length=255), autoincrement=False, nullable=False
        ),
        sa.Column(
            "sender_pattern", sa.VARCHAR(length=255), autoincrement=False, nullable=True
        ),
        sa.Column(
            "merchant_name", sa.VARCHAR(length=255), autoincrement=False, nullable=False
        ),
        sa.Column(
            "normalized_name",
            sa.VARCHAR(length=255),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column(
            "parse_type", sa.VARCHAR(length=20), autoincrement=False, nullable=False
        ),
        sa.Column(
            "pattern_config",
            postgresql.JSONB(astext_type=sa.Text()),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "date_tolerance_days",
            sa.INTEGER(),
            server_default=sa.text("7"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "is_active",
            sa.BOOLEAN(),
            server_default=sa.text("true"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "usage_count",
            sa.INTEGER(),
            server_default=sa.text("0"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "last_used_at",
            postgresql.TIMESTAMP(timezone=True),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(timezone=True),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=True,
        ),
        sa.CheckConstraint(
            "parse_type::text = ANY (ARRAY['schema_org'::character varying, 'pattern'::character varying, 'llm'::character varying]::text[])",
            name="gmail_sender_patterns_parse_type_check",
        ),
        sa.PrimaryKeyConstraint("id", name="gmail_sender_patterns_pkey"),
    )
    op.create_index(
        "idx_gmail_sender_patterns_domain",
        "gmail_sender_patterns",
        ["sender_domain"],
        unique=False,
    )
    op.create_index(
        "idx_gmail_sender_patterns_active",
        "gmail_sender_patterns",
        ["is_active"],
        unique=False,
        postgresql_where="(is_active = true)",
    )
    op.create_table(
        "truelayer_card_transactions",
        sa.Column("id", sa.INTEGER(), autoincrement=True, nullable=False),
        sa.Column("card_id", sa.INTEGER(), autoincrement=False, nullable=False),
        sa.Column(
            "transaction_id", sa.VARCHAR(length=255), autoincrement=False, nullable=True
        ),
        sa.Column(
            "normalised_provider_id",
            sa.VARCHAR(length=255),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "timestamp", postgresql.TIMESTAMP(), autoincrement=False, nullable=True
        ),
        sa.Column("description", sa.TEXT(), autoincrement=False, nullable=True),
        sa.Column("amount", sa.NUMERIC(), autoincrement=False, nullable=True),
        sa.Column("currency", sa.VARCHAR(length=3), autoincrement=False, nullable=True),
        sa.Column(
            "transaction_type",
            sa.VARCHAR(length=50),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "category", sa.VARCHAR(length=255), autoincrement=False, nullable=True
        ),
        sa.Column(
            "merchant_name", sa.VARCHAR(length=255), autoincrement=False, nullable=True
        ),
        sa.Column("running_balance", sa.NUMERIC(), autoincrement=False, nullable=True),
        sa.Column("metadata", sa.TEXT(), autoincrement=False, nullable=True),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(),
            server_default=sa.text("CURRENT_TIMESTAMP"),
            autoincrement=False,
            nullable=True,
        ),
        sa.ForeignKeyConstraint(
            ["card_id"],
            ["truelayer_cards.id"],
            name="truelayer_card_transactions_card_id_fkey",
            ondelete="CASCADE",
        ),
        sa.PrimaryKeyConstraint("id", name="truelayer_card_transactions_pkey"),
        sa.UniqueConstraint(
            "normalised_provider_id",
            name="truelayer_card_transactions_normalised_provider_id_key",
            postgresql_include=[],
            postgresql_nulls_not_distinct=False,
        ),
    )
    op.create_index(
        "idx_truelayer_card_transactions_timestamp",
        "truelayer_card_transactions",
        ["timestamp"],
        unique=False,
    )
    op.create_index(
        "idx_truelayer_card_transactions_card",
        "truelayer_card_transactions",
        ["card_id"],
        unique=False,
    )
    op.create_table(
        "webhook_events",
        sa.Column("id", sa.INTEGER(), autoincrement=True, nullable=False),
        sa.Column(
            "event_id", sa.VARCHAR(length=255), autoincrement=False, nullable=False
        ),
        sa.Column(
            "event_type", sa.VARCHAR(length=100), autoincrement=False, nullable=False
        ),
        sa.Column(
            "payload",
            postgresql.JSONB(astext_type=sa.Text()),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column("signature", sa.TEXT(), autoincrement=False, nullable=False),
        sa.Column(
            "processed",
            sa.BOOLEAN(),
            server_default=sa.text("false"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "processed_at",
            postgresql.TIMESTAMP(timezone=True),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "received_at",
            postgresql.TIMESTAMP(timezone=True),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=True,
        ),
        sa.PrimaryKeyConstraint("id", name="webhook_events_pkey"),
        sa.UniqueConstraint(
            "event_id",
            name="webhook_events_event_id_key",
            postgresql_include=[],
            postgresql_nulls_not_distinct=False,
        ),
        comment="TrueLayer webhook events for asynchronous processing",
    )
    op.create_index(
        "idx_webhook_events_unprocessed",
        "webhook_events",
        ["received_at"],
        unique=False,
        postgresql_where="(processed = false)",
    )
    op.create_index(
        "idx_webhook_events_event_id", "webhook_events", ["event_id"], unique=False
    )
    op.create_table(
        "category_rules",
        sa.Column("id", sa.INTEGER(), autoincrement=True, nullable=False),
        sa.Column(
            "rule_name", sa.VARCHAR(length=100), autoincrement=False, nullable=False
        ),
        sa.Column(
            "transaction_type",
            sa.VARCHAR(length=10),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "description_pattern",
            sa.VARCHAR(length=255),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column(
            "pattern_type",
            sa.VARCHAR(length=20),
            server_default=sa.text("'contains'::character varying"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "category", sa.VARCHAR(length=100), autoincrement=False, nullable=False
        ),
        sa.Column(
            "subcategory", sa.VARCHAR(length=100), autoincrement=False, nullable=True
        ),
        sa.Column(
            "priority",
            sa.INTEGER(),
            server_default=sa.text("0"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "is_active",
            sa.BOOLEAN(),
            server_default=sa.text("true"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "source",
            sa.VARCHAR(length=50),
            server_default=sa.text("'manual'::character varying"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "usage_count",
            sa.INTEGER(),
            server_default=sa.text("0"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column("category_id", sa.INTEGER(), autoincrement=False, nullable=True),
        sa.Column("subcategory_id", sa.INTEGER(), autoincrement=False, nullable=True),
        sa.ForeignKeyConstraint(
            ["category_id"],
            ["normalized_categories.id"],
            name="category_rules_category_id_fkey",
        ),
        sa.ForeignKeyConstraint(
            ["subcategory_id"],
            ["normalized_subcategories.id"],
            name="category_rules_subcategory_id_fkey",
        ),
        sa.PrimaryKeyConstraint("id", name="category_rules_pkey"),
    )
    op.create_index(
        "idx_category_rules_type", "category_rules", ["transaction_type"], unique=False
    )
    op.create_index(
        "idx_category_rules_subcategory_id",
        "category_rules",
        ["subcategory_id"],
        unique=False,
    )
    op.create_index(
        "idx_category_rules_priority",
        "category_rules",
        [sa.literal_column("priority DESC")],
        unique=False,
    )
    op.create_index(
        "idx_category_rules_pattern",
        "category_rules",
        ["description_pattern"],
        unique=False,
    )
    op.create_index(
        "idx_category_rules_category_id",
        "category_rules",
        ["category_id"],
        unique=False,
    )
    op.create_table(
        "gmail_transaction_matches",
        sa.Column("id", sa.INTEGER(), autoincrement=True, nullable=False),
        sa.Column(
            "truelayer_transaction_id",
            sa.INTEGER(),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column(
            "gmail_receipt_id", sa.INTEGER(), autoincrement=False, nullable=False
        ),
        sa.Column(
            "match_confidence", sa.INTEGER(), autoincrement=False, nullable=False
        ),
        sa.Column(
            "match_type",
            sa.VARCHAR(length=20),
            server_default=sa.text("'standard'::character varying"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "match_method", sa.VARCHAR(length=100), autoincrement=False, nullable=True
        ),
        sa.Column(
            "currency_converted",
            sa.BOOLEAN(),
            server_default=sa.text("false"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "conversion_rate",
            sa.NUMERIC(precision=10, scale=6),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "user_confirmed",
            sa.BOOLEAN(),
            server_default=sa.text("false"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "matched_at",
            postgresql.TIMESTAMP(timezone=True),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=True,
        ),
        sa.CheckConstraint(
            "match_type::text = ANY (ARRAY['standard'::character varying, 'split_payment'::character varying, 'bundled_order'::character varying]::text[])",
            name="gmail_transaction_matches_match_type_check",
        ),
        sa.CheckConstraint(
            "match_confidence >= 0 AND match_confidence <= 100",
            name="gmail_transaction_matches_match_confidence_check",
        ),
        sa.ForeignKeyConstraint(
            ["gmail_receipt_id"],
            ["gmail_receipts.id"],
            name="gmail_transaction_matches_gmail_receipt_id_fkey",
            ondelete="CASCADE",
        ),
        sa.ForeignKeyConstraint(
            ["truelayer_transaction_id"],
            ["truelayer_transactions.id"],
            name="gmail_transaction_matches_truelayer_transaction_id_fkey",
            ondelete="CASCADE",
        ),
        sa.PrimaryKeyConstraint("id", name="gmail_transaction_matches_pkey"),
        sa.UniqueConstraint(
            "truelayer_transaction_id",
            "gmail_receipt_id",
            name="gmail_match_unique",
            postgresql_include=[],
            postgresql_nulls_not_distinct=False,
        ),
    )
    op.create_index(
        "idx_gmail_matches_unconfirmed",
        "gmail_transaction_matches",
        ["match_confidence"],
        unique=False,
        postgresql_where="((match_confidence < 80) AND (user_confirmed = false))",
    )
    op.create_index(
        "idx_gmail_matches_transaction",
        "gmail_transaction_matches",
        ["truelayer_transaction_id"],
        unique=False,
    )
    op.create_index(
        "idx_gmail_matches_receipt",
        "gmail_transaction_matches",
        ["gmail_receipt_id"],
        unique=False,
    )
    op.create_table(
        "gmail_processing_errors",
        sa.Column("id", sa.INTEGER(), autoincrement=True, nullable=False),
        sa.Column("connection_id", sa.INTEGER(), autoincrement=False, nullable=True),
        sa.Column("sync_job_id", sa.INTEGER(), autoincrement=False, nullable=True),
        sa.Column(
            "message_id", sa.VARCHAR(length=255), autoincrement=False, nullable=True
        ),
        sa.Column("receipt_id", sa.INTEGER(), autoincrement=False, nullable=True),
        sa.Column(
            "error_stage", sa.VARCHAR(length=30), autoincrement=False, nullable=False
        ),
        sa.Column(
            "error_type", sa.VARCHAR(length=30), autoincrement=False, nullable=False
        ),
        sa.Column("error_message", sa.TEXT(), autoincrement=False, nullable=False),
        sa.Column("stack_trace", sa.TEXT(), autoincrement=False, nullable=True),
        sa.Column(
            "error_context",
            postgresql.JSONB(astext_type=sa.Text()),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "is_retryable",
            sa.BOOLEAN(),
            server_default=sa.text("false"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "retry_count",
            sa.INTEGER(),
            server_default=sa.text("0"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "last_retry_at",
            postgresql.TIMESTAMP(timezone=True),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "occurred_at",
            postgresql.TIMESTAMP(timezone=True),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=False,
        ),
        sa.CheckConstraint(
            "error_stage::text = ANY (ARRAY['fetch'::character varying, 'parse'::character varying, 'vendor_parse'::character varying, 'schema_parse'::character varying, 'pattern_parse'::character varying, 'llm_parse'::character varying, 'pdf_parse'::character varying, 'storage'::character varying, 'match'::character varying, 'validation'::character varying]::text[])",
            name="gmail_processing_errors_error_stage_check",
        ),
        sa.CheckConstraint(
            "error_type::text = ANY (ARRAY['api_error'::character varying, 'timeout'::character varying, 'parse_error'::character varying, 'validation'::character varying, 'db_error'::character varying, 'network'::character varying, 'rate_limit'::character varying, 'auth_error'::character varying, 'unknown'::character varying]::text[])",
            name="gmail_processing_errors_error_type_check",
        ),
        sa.ForeignKeyConstraint(
            ["connection_id"],
            ["gmail_connections.id"],
            name="gmail_processing_errors_connection_id_fkey",
            ondelete="CASCADE",
        ),
        sa.ForeignKeyConstraint(
            ["receipt_id"],
            ["gmail_receipts.id"],
            name="gmail_processing_errors_receipt_id_fkey",
            ondelete="CASCADE",
        ),
        sa.ForeignKeyConstraint(
            ["sync_job_id"],
            ["gmail_sync_jobs.id"],
            name="gmail_processing_errors_sync_job_id_fkey",
            ondelete="SET NULL",
        ),
        sa.PrimaryKeyConstraint("id", name="gmail_processing_errors_pkey"),
    )
    op.create_index(
        "idx_errors_type", "gmail_processing_errors", ["error_type"], unique=False
    )
    op.create_index(
        "idx_errors_stage", "gmail_processing_errors", ["error_stage"], unique=False
    )
    op.create_index(
        "idx_errors_occurred", "gmail_processing_errors", ["occurred_at"], unique=False
    )
    op.create_index(
        "idx_errors_job", "gmail_processing_errors", ["sync_job_id"], unique=False
    )
    op.create_index(
        "idx_errors_connection",
        "gmail_processing_errors",
        ["connection_id"],
        unique=False,
    )
    op.create_table(
        "truelayer_cards",
        sa.Column(
            "id",
            sa.INTEGER(),
            server_default=sa.text("nextval('truelayer_cards_id_seq'::regclass)"),
            autoincrement=True,
            nullable=False,
        ),
        sa.Column("connection_id", sa.INTEGER(), autoincrement=False, nullable=False),
        sa.Column(
            "card_id", sa.VARCHAR(length=255), autoincrement=False, nullable=False
        ),
        sa.Column(
            "card_name", sa.VARCHAR(length=255), autoincrement=False, nullable=True
        ),
        sa.Column(
            "card_type", sa.VARCHAR(length=50), autoincrement=False, nullable=True
        ),
        sa.Column(
            "last_four", sa.VARCHAR(length=4), autoincrement=False, nullable=True
        ),
        sa.Column("issuer", sa.VARCHAR(length=255), autoincrement=False, nullable=True),
        sa.Column("status", sa.VARCHAR(length=50), autoincrement=False, nullable=True),
        sa.Column(
            "last_synced_at", postgresql.TIMESTAMP(), autoincrement=False, nullable=True
        ),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(),
            server_default=sa.text("CURRENT_TIMESTAMP"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "updated_at",
            postgresql.TIMESTAMP(),
            server_default=sa.text("CURRENT_TIMESTAMP"),
            autoincrement=False,
            nullable=True,
        ),
        sa.ForeignKeyConstraint(
            ["connection_id"],
            ["bank_connections.id"],
            name="truelayer_cards_connection_id_fkey",
            ondelete="CASCADE",
        ),
        sa.PrimaryKeyConstraint("id", name="truelayer_cards_pkey"),
        sa.UniqueConstraint(
            "connection_id",
            "card_id",
            name="truelayer_cards_connection_id_card_id_key",
            postgresql_include=[],
            postgresql_nulls_not_distinct=False,
        ),
        postgresql_ignore_search_path=False,
    )
    op.create_index(
        "idx_truelayer_cards_connection",
        "truelayer_cards",
        ["connection_id"],
        unique=False,
    )
    op.create_table(
        "user_sessions",
        sa.Column("id", sa.VARCHAR(length=255), autoincrement=False, nullable=False),
        sa.Column("user_id", sa.INTEGER(), autoincrement=False, nullable=True),
        sa.Column(
            "session_data",
            postgresql.JSONB(astext_type=sa.Text()),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(),
            server_default=sa.text("CURRENT_TIMESTAMP"),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column(
            "expires_at", postgresql.TIMESTAMP(), autoincrement=False, nullable=False
        ),
        sa.Column(
            "last_activity_at",
            postgresql.TIMESTAMP(),
            server_default=sa.text("CURRENT_TIMESTAMP"),
            autoincrement=False,
            nullable=False,
        ),
        sa.ForeignKeyConstraint(
            ["user_id"],
            ["users.id"],
            name="user_sessions_user_id_fkey",
            ondelete="CASCADE",
        ),
        sa.PrimaryKeyConstraint("id", name="user_sessions_pkey"),
        comment="User session tracking (alternative to Redis-only sessions)",
    )
    op.create_index(
        "idx_user_sessions_user_id", "user_sessions", ["user_id"], unique=False
    )
    op.create_index(
        "idx_user_sessions_expires_at", "user_sessions", ["expires_at"], unique=False
    )
    op.create_table(
        "truelayer_import_progress",
        sa.Column("id", sa.INTEGER(), autoincrement=True, nullable=False),
        sa.Column("job_id", sa.INTEGER(), autoincrement=False, nullable=False),
        sa.Column("account_id", sa.INTEGER(), autoincrement=False, nullable=True),
        sa.Column(
            "progress_status",
            sa.VARCHAR(length=20),
            server_default=sa.text("'pending'::character varying"),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column(
            "synced_count",
            sa.INTEGER(),
            server_default=sa.text("0"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "duplicates_count",
            sa.INTEGER(),
            server_default=sa.text("0"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "errors_count",
            sa.INTEGER(),
            server_default=sa.text("0"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "started_at",
            postgresql.TIMESTAMP(timezone=True),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "completed_at",
            postgresql.TIMESTAMP(timezone=True),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column("error_message", sa.TEXT(), autoincrement=False, nullable=True),
        sa.Column(
            "metadata",
            postgresql.JSONB(astext_type=sa.Text()),
            server_default=sa.text("'{}'::jsonb"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(timezone=True),
            server_default=sa.text("CURRENT_TIMESTAMP"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "updated_at",
            postgresql.TIMESTAMP(timezone=True),
            server_default=sa.text("CURRENT_TIMESTAMP"),
            autoincrement=False,
            nullable=True,
        ),
        sa.CheckConstraint(
            "progress_status::text = ANY (ARRAY['pending'::character varying, 'syncing'::character varying, 'completed'::character varying, 'failed'::character varying]::text[])",
            name="valid_status",
        ),
        sa.ForeignKeyConstraint(
            ["account_id"],
            ["truelayer_accounts.id"],
            name="truelayer_import_progress_account_id_fkey",
            ondelete="SET NULL",
        ),
        sa.ForeignKeyConstraint(
            ["job_id"],
            ["truelayer_import_jobs.id"],
            name="truelayer_import_progress_job_id_fkey",
            ondelete="CASCADE",
        ),
        sa.PrimaryKeyConstraint("id", name="truelayer_import_progress_pkey"),
    )
    op.create_index(
        "idx_import_progress_status",
        "truelayer_import_progress",
        ["progress_status"],
        unique=False,
    )
    op.create_index(
        "idx_import_progress_job_id",
        "truelayer_import_progress",
        ["job_id"],
        unique=False,
    )
    op.create_index(
        "idx_import_progress_account_id",
        "truelayer_import_progress",
        ["account_id"],
        unique=False,
    )
    op.create_table(
        "truelayer_card_balance_snapshots",
        sa.Column("id", sa.INTEGER(), autoincrement=True, nullable=False),
        sa.Column("card_id", sa.INTEGER(), autoincrement=False, nullable=False),
        sa.Column("current_balance", sa.NUMERIC(), autoincrement=False, nullable=True),
        sa.Column("currency", sa.VARCHAR(length=3), autoincrement=False, nullable=True),
        sa.Column(
            "snapshot_at", postgresql.TIMESTAMP(), autoincrement=False, nullable=True
        ),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(),
            server_default=sa.text("CURRENT_TIMESTAMP"),
            autoincrement=False,
            nullable=True,
        ),
        sa.ForeignKeyConstraint(
            ["card_id"],
            ["truelayer_cards.id"],
            name="truelayer_card_balance_snapshots_card_id_fkey",
            ondelete="CASCADE",
        ),
        sa.PrimaryKeyConstraint("id", name="truelayer_card_balance_snapshots_pkey"),
    )
    op.create_index(
        "idx_truelayer_card_balance_snapshots_card",
        "truelayer_card_balance_snapshots",
        ["card_id"],
        unique=False,
    )
    op.create_table(
        "connection_logs",
        sa.Column("id", sa.INTEGER(), autoincrement=True, nullable=False),
        sa.Column("connection_id", sa.INTEGER(), autoincrement=False, nullable=True),
        sa.Column(
            "event_type", sa.VARCHAR(length=50), autoincrement=False, nullable=False
        ),
        sa.Column(
            "details",
            postgresql.JSONB(astext_type=sa.Text()),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(timezone=True),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=True,
        ),
        sa.ForeignKeyConstraint(
            ["connection_id"],
            ["bank_connections.id"],
            name="connection_logs_connection_id_fkey",
            ondelete="CASCADE",
        ),
        sa.PrimaryKeyConstraint("id", name="connection_logs_pkey"),
    )
    op.create_index(
        "idx_connection_logs_created_at",
        "connection_logs",
        ["created_at"],
        unique=False,
    )
    op.create_index(
        "idx_connection_logs_connection_id",
        "connection_logs",
        ["connection_id"],
        unique=False,
    )
    op.create_table(
        "normalized_subcategories",
        sa.Column(
            "id",
            sa.INTEGER(),
            server_default=sa.text(
                "nextval('normalized_subcategories_id_seq'::regclass)"
            ),
            autoincrement=True,
            nullable=False,
        ),
        sa.Column("category_id", sa.INTEGER(), autoincrement=False, nullable=False),
        sa.Column("name", sa.VARCHAR(length=255), autoincrement=False, nullable=False),
        sa.Column("description", sa.TEXT(), autoincrement=False, nullable=True),
        sa.Column(
            "is_active",
            sa.BOOLEAN(),
            server_default=sa.text("true"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "display_order",
            sa.INTEGER(),
            server_default=sa.text("0"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(timezone=True),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "updated_at",
            postgresql.TIMESTAMP(timezone=True),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=True,
        ),
        sa.ForeignKeyConstraint(
            ["category_id"],
            ["normalized_categories.id"],
            name="normalized_subcategories_category_id_fkey",
            ondelete="CASCADE",
        ),
        sa.PrimaryKeyConstraint("id", name="normalized_subcategories_pkey"),
        sa.UniqueConstraint(
            "category_id",
            "name",
            name="normalized_subcategories_category_id_name_key",
            postgresql_include=[],
            postgresql_nulls_not_distinct=False,
        ),
        postgresql_ignore_search_path=False,
    )
    op.create_index(
        "idx_normalized_subcategories_name",
        "normalized_subcategories",
        ["name"],
        unique=False,
    )
    op.create_index(
        "idx_normalized_subcategories_category",
        "normalized_subcategories",
        ["category_id"],
        unique=False,
    )
    op.create_table(
        "merchant_normalizations",
        sa.Column("id", sa.INTEGER(), autoincrement=True, nullable=False),
        sa.Column(
            "pattern", sa.VARCHAR(length=255), autoincrement=False, nullable=False
        ),
        sa.Column(
            "pattern_type",
            sa.VARCHAR(length=20),
            server_default=sa.text("'contains'::character varying"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "normalized_name",
            sa.VARCHAR(length=255),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column(
            "merchant_type", sa.VARCHAR(length=100), autoincrement=False, nullable=True
        ),
        sa.Column(
            "default_category",
            sa.VARCHAR(length=100),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "priority",
            sa.INTEGER(),
            server_default=sa.text("0"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "source",
            sa.VARCHAR(length=50),
            server_default=sa.text("'manual'::character varying"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "usage_count",
            sa.INTEGER(),
            server_default=sa.text("0"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "updated_at",
            postgresql.TIMESTAMP(),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=True,
        ),
        sa.PrimaryKeyConstraint("id", name="merchant_normalizations_pkey"),
        sa.UniqueConstraint(
            "pattern",
            "pattern_type",
            name="merchant_normalizations_pattern_pattern_type_key",
            postgresql_include=[],
            postgresql_nulls_not_distinct=False,
        ),
    )
    op.create_index(
        "idx_merchant_norm_priority",
        "merchant_normalizations",
        [sa.literal_column("priority DESC")],
        unique=False,
    )
    op.create_index(
        "idx_merchant_norm_pattern",
        "merchant_normalizations",
        ["pattern"],
        unique=False,
    )
    op.create_table(
        "truelayer_enrichment_jobs",
        sa.Column(
            "id",
            sa.INTEGER(),
            server_default=sa.text(
                "nextval('truelayer_enrichment_jobs_id_seq'::regclass)"
            ),
            autoincrement=True,
            nullable=False,
        ),
        sa.Column("user_id", sa.INTEGER(), autoincrement=False, nullable=False),
        sa.Column("import_job_id", sa.INTEGER(), autoincrement=False, nullable=True),
        sa.Column(
            "job_status",
            sa.VARCHAR(length=20),
            server_default=sa.text("'pending'::character varying"),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column(
            "transaction_ids",
            postgresql.ARRAY(sa.INTEGER()),
            server_default=sa.text("ARRAY[]::integer[]"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "total_transactions",
            sa.INTEGER(),
            server_default=sa.text("0"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "successful_enrichments",
            sa.INTEGER(),
            server_default=sa.text("0"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "failed_enrichments",
            sa.INTEGER(),
            server_default=sa.text("0"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "cached_hits",
            sa.INTEGER(),
            server_default=sa.text("0"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "total_cost",
            sa.NUMERIC(precision=10, scale=4),
            server_default=sa.text("0.00"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "total_tokens",
            sa.INTEGER(),
            server_default=sa.text("0"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "llm_provider", sa.VARCHAR(length=50), autoincrement=False, nullable=True
        ),
        sa.Column(
            "llm_model", sa.VARCHAR(length=100), autoincrement=False, nullable=True
        ),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(timezone=True),
            server_default=sa.text("CURRENT_TIMESTAMP"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "started_at",
            postgresql.TIMESTAMP(timezone=True),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "completed_at",
            postgresql.TIMESTAMP(timezone=True),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "metadata",
            postgresql.JSONB(astext_type=sa.Text()),
            server_default=sa.text("'{}'::jsonb"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column("error_message", sa.TEXT(), autoincrement=False, nullable=True),
        sa.CheckConstraint(
            "job_status::text = ANY (ARRAY['pending'::character varying, 'running'::character varying, 'completed'::character varying, 'failed'::character varying]::text[])",
            name="valid_enrichment_status",
        ),
        sa.ForeignKeyConstraint(
            ["import_job_id"],
            ["truelayer_import_jobs.id"],
            name="truelayer_enrichment_jobs_import_job_id_fkey",
            ondelete="SET NULL",
        ),
        sa.ForeignKeyConstraint(
            ["user_id"],
            ["users.id"],
            name="truelayer_enrichment_jobs_user_id_fkey",
            ondelete="CASCADE",
        ),
        sa.PrimaryKeyConstraint("id", name="truelayer_enrichment_jobs_pkey"),
        postgresql_ignore_search_path=False,
    )
    op.create_index(
        "idx_enrichment_jobs_user_id",
        "truelayer_enrichment_jobs",
        ["user_id"],
        unique=False,
    )
    op.create_index(
        "idx_enrichment_jobs_status",
        "truelayer_enrichment_jobs",
        ["job_status"],
        unique=False,
    )
    op.create_index(
        "idx_enrichment_jobs_import_job_id",
        "truelayer_enrichment_jobs",
        ["import_job_id"],
        unique=False,
    )
    op.create_index(
        "idx_enrichment_jobs_created_at",
        "truelayer_enrichment_jobs",
        [sa.literal_column("created_at DESC")],
        unique=False,
    )
    op.create_table(
        "truelayer_amazon_business_matches",
        sa.Column("id", sa.INTEGER(), autoincrement=True, nullable=False),
        sa.Column(
            "truelayer_transaction_id",
            sa.INTEGER(),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column(
            "amazon_business_order_id",
            sa.INTEGER(),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column(
            "match_confidence", sa.INTEGER(), autoincrement=False, nullable=False
        ),
        sa.Column(
            "matched_at",
            postgresql.TIMESTAMP(timezone=True),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=True,
        ),
        sa.ForeignKeyConstraint(
            ["amazon_business_order_id"],
            ["amazon_business_orders.id"],
            name="truelayer_amazon_business_matches_amazon_business_order_id_fkey",
        ),
        sa.ForeignKeyConstraint(
            ["truelayer_transaction_id"],
            ["truelayer_transactions.id"],
            name="truelayer_amazon_business_matches_truelayer_transaction_id_fkey",
        ),
        sa.PrimaryKeyConstraint("id", name="truelayer_amazon_business_matches_pkey"),
        sa.UniqueConstraint(
            "truelayer_transaction_id",
            name="truelayer_amazon_business_unique",
            postgresql_include=[],
            postgresql_nulls_not_distinct=False,
        ),
    )
    op.create_index(
        "idx_ab_matches_order",
        "truelayer_amazon_business_matches",
        ["amazon_business_order_id"],
        unique=False,
    )
    op.create_table(
        "subcategory_mappings",
        sa.Column("id", sa.INTEGER(), autoincrement=True, nullable=False),
        sa.Column(
            "custom_category_id", sa.INTEGER(), autoincrement=False, nullable=False
        ),
        sa.Column(
            "subcategory_name",
            sa.VARCHAR(length=255),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column(
            "original_category",
            sa.VARCHAR(length=100),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(timezone=True),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=True,
        ),
        sa.ForeignKeyConstraint(
            ["custom_category_id"],
            ["custom_categories.id"],
            name="subcategory_mappings_custom_category_id_fkey",
            ondelete="CASCADE",
        ),
        sa.PrimaryKeyConstraint("id", name="subcategory_mappings_pkey"),
        sa.UniqueConstraint(
            "custom_category_id",
            "subcategory_name",
            name="subcategory_mappings_custom_category_id_subcategory_name_key",
            postgresql_include=[],
            postgresql_nulls_not_distinct=False,
        ),
    )
    op.create_index(
        "idx_subcategory_mappings_subcategory",
        "subcategory_mappings",
        ["subcategory_name"],
        unique=False,
    )
    op.create_index(
        "idx_subcategory_mappings_category",
        "subcategory_mappings",
        ["custom_category_id"],
        unique=False,
    )
    op.create_table(
        "gmail_parse_statistics",
        sa.Column("id", sa.INTEGER(), autoincrement=True, nullable=False),
        sa.Column("connection_id", sa.INTEGER(), autoincrement=False, nullable=False),
        sa.Column("sync_job_id", sa.INTEGER(), autoincrement=False, nullable=True),
        sa.Column(
            "message_id", sa.VARCHAR(length=255), autoincrement=False, nullable=False
        ),
        sa.Column(
            "sender_domain", sa.VARCHAR(length=255), autoincrement=False, nullable=False
        ),
        sa.Column(
            "merchant_normalized",
            sa.VARCHAR(length=255),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "parse_method", sa.VARCHAR(length=30), autoincrement=False, nullable=True
        ),
        sa.Column(
            "merchant_extracted", sa.BOOLEAN(), autoincrement=False, nullable=True
        ),
        sa.Column("brand_extracted", sa.BOOLEAN(), autoincrement=False, nullable=True),
        sa.Column("amount_extracted", sa.BOOLEAN(), autoincrement=False, nullable=True),
        sa.Column("date_extracted", sa.BOOLEAN(), autoincrement=False, nullable=True),
        sa.Column(
            "order_id_extracted", sa.BOOLEAN(), autoincrement=False, nullable=True
        ),
        sa.Column(
            "line_items_extracted", sa.BOOLEAN(), autoincrement=False, nullable=True
        ),
        sa.Column(
            "match_attempted",
            sa.BOOLEAN(),
            server_default=sa.text("false"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column("match_success", sa.BOOLEAN(), autoincrement=False, nullable=True),
        sa.Column("match_confidence", sa.INTEGER(), autoincrement=False, nullable=True),
        sa.Column(
            "parse_duration_ms", sa.INTEGER(), autoincrement=False, nullable=True
        ),
        sa.Column("llm_cost_cents", sa.INTEGER(), autoincrement=False, nullable=True),
        sa.Column(
            "parsing_status", sa.VARCHAR(length=20), autoincrement=False, nullable=False
        ),
        sa.Column("parsing_error", sa.TEXT(), autoincrement=False, nullable=True),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(timezone=True),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=False,
        ),
        sa.CheckConstraint(
            "parse_method::text = ANY (ARRAY['vendor_amazon'::character varying, 'vendor_uber'::character varying, 'vendor_apple'::character varying, 'vendor_paypal'::character varying, 'vendor_deliveroo'::character varying, 'vendor_google'::character varying, 'schema_org'::character varying, 'pattern'::character varying, 'llm'::character varying, 'pdf_fallback'::character varying, 'pre_filter'::character varying, 'unknown'::character varying]::text[])",
            name="gmail_parse_statistics_parse_method_check",
        ),
        sa.CheckConstraint(
            "parsing_status::text = ANY (ARRAY['parsed'::character varying, 'unparseable'::character varying, 'filtered'::character varying, 'failed'::character varying]::text[])",
            name="gmail_parse_statistics_parsing_status_check",
        ),
        sa.ForeignKeyConstraint(
            ["connection_id"],
            ["gmail_connections.id"],
            name="gmail_parse_statistics_connection_id_fkey",
            ondelete="CASCADE",
        ),
        sa.ForeignKeyConstraint(
            ["sync_job_id"],
            ["gmail_sync_jobs.id"],
            name="gmail_parse_statistics_sync_job_id_fkey",
            ondelete="SET NULL",
        ),
        sa.PrimaryKeyConstraint("id", name="gmail_parse_statistics_pkey"),
    )
    op.create_index(
        "idx_parse_stats_sender",
        "gmail_parse_statistics",
        ["sender_domain"],
        unique=False,
    )
    op.create_index(
        "idx_parse_stats_method",
        "gmail_parse_statistics",
        ["parse_method"],
        unique=False,
    )
    op.create_index(
        "idx_parse_stats_merchant_method",
        "gmail_parse_statistics",
        ["merchant_normalized", "parse_method"],
        unique=False,
    )
    op.create_index(
        "idx_parse_stats_merchant",
        "gmail_parse_statistics",
        ["merchant_normalized"],
        unique=False,
    )
    op.create_index(
        "idx_parse_stats_job", "gmail_parse_statistics", ["sync_job_id"], unique=False
    )
    op.create_table(
        "truelayer_connections",
        sa.Column("id", sa.INTEGER(), autoincrement=True, nullable=False),
        sa.Column("user_id", sa.INTEGER(), autoincrement=False, nullable=False),
        sa.Column(
            "provider_id", sa.VARCHAR(length=100), autoincrement=False, nullable=True
        ),
        sa.Column("access_token", sa.TEXT(), autoincrement=False, nullable=False),
        sa.Column("refresh_token", sa.TEXT(), autoincrement=False, nullable=True),
        sa.Column(
            "token_expires_at",
            postgresql.TIMESTAMP(),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "connection_status",
            sa.VARCHAR(length=50),
            server_default=sa.text("'active'::character varying"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "last_synced_at", postgresql.TIMESTAMP(), autoincrement=False, nullable=True
        ),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(),
            server_default=sa.text("CURRENT_TIMESTAMP"),
            autoincrement=False,
            nullable=True,
        ),
        sa.ForeignKeyConstraint(
            ["user_id"],
            ["users.id"],
            name="truelayer_connections_user_id_fkey",
            ondelete="CASCADE",
        ),
        sa.PrimaryKeyConstraint("id", name="truelayer_connections_pkey"),
    )
    op.create_table(
        "matching_jobs",
        sa.Column("id", sa.INTEGER(), autoincrement=True, nullable=False),
        sa.Column(
            "user_id",
            sa.INTEGER(),
            server_default=sa.text("1"),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column(
            "job_type", sa.VARCHAR(length=50), autoincrement=False, nullable=False
        ),
        sa.Column(
            "celery_task_id", sa.VARCHAR(length=255), autoincrement=False, nullable=True
        ),
        sa.Column(
            "status",
            sa.VARCHAR(length=20),
            server_default=sa.text("'queued'::character varying"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "total_items",
            sa.INTEGER(),
            server_default=sa.text("0"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "processed_items",
            sa.INTEGER(),
            server_default=sa.text("0"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "matched_items",
            sa.INTEGER(),
            server_default=sa.text("0"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "failed_items",
            sa.INTEGER(),
            server_default=sa.text("0"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column("error_message", sa.TEXT(), autoincrement=False, nullable=True),
        sa.Column(
            "started_at", postgresql.TIMESTAMP(), autoincrement=False, nullable=True
        ),
        sa.Column(
            "completed_at", postgresql.TIMESTAMP(), autoincrement=False, nullable=True
        ),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(),
            server_default=sa.text("CURRENT_TIMESTAMP"),
            autoincrement=False,
            nullable=True,
        ),
        sa.PrimaryKeyConstraint("id", name="matching_jobs_pkey"),
        comment="Tracks async matching jobs for Amazon, Apple, and Returns matching operations",
    )
    op.create_index(
        "idx_matching_jobs_user_status",
        "matching_jobs",
        ["user_id", "status"],
        unique=False,
    )
    op.create_index(
        "idx_matching_jobs_celery_task",
        "matching_jobs",
        ["celery_task_id"],
        unique=False,
    )
    op.create_table(
        "account_mappings",
        sa.Column("id", sa.INTEGER(), autoincrement=True, nullable=False),
        sa.Column(
            "sort_code", sa.VARCHAR(length=10), autoincrement=False, nullable=False
        ),
        sa.Column(
            "account_number", sa.VARCHAR(length=20), autoincrement=False, nullable=False
        ),
        sa.Column(
            "friendly_name", sa.VARCHAR(length=255), autoincrement=False, nullable=False
        ),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(timezone=True),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=True,
        ),
        sa.PrimaryKeyConstraint("id", name="account_mappings_pkey"),
        sa.UniqueConstraint(
            "sort_code",
            "account_number",
            name="account_mappings_sort_code_account_number_key",
            postgresql_include=[],
            postgresql_nulls_not_distinct=False,
        ),
    )
    op.create_table(
        "truelayer_oauth_state",
        sa.Column("id", sa.INTEGER(), autoincrement=True, nullable=False),
        sa.Column("user_id", sa.INTEGER(), autoincrement=False, nullable=False),
        sa.Column("state", sa.TEXT(), autoincrement=False, nullable=False),
        sa.Column("code_verifier", sa.TEXT(), autoincrement=False, nullable=False),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=False,
        ),
        sa.PrimaryKeyConstraint("id", name="truelayer_oauth_state_pkey"),
        sa.UniqueConstraint(
            "state",
            name="truelayer_oauth_state_state_key",
            postgresql_include=[],
            postgresql_nulls_not_distinct=False,
        ),
    )
    op.create_table(
        "gmail_oauth_state",
        sa.Column("id", sa.INTEGER(), autoincrement=True, nullable=False),
        sa.Column("user_id", sa.INTEGER(), autoincrement=False, nullable=False),
        sa.Column("state", sa.VARCHAR(length=255), autoincrement=False, nullable=False),
        sa.Column(
            "code_verifier", sa.VARCHAR(length=255), autoincrement=False, nullable=False
        ),
        sa.Column(
            "expires_at",
            postgresql.TIMESTAMP(timezone=True),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(timezone=True),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=True,
        ),
        sa.PrimaryKeyConstraint("id", name="gmail_oauth_state_pkey"),
        sa.UniqueConstraint(
            "state",
            name="gmail_oauth_state_state_key",
            postgresql_include=[],
            postgresql_nulls_not_distinct=False,
        ),
    )
    op.create_index(
        "idx_gmail_oauth_state_state", "gmail_oauth_state", ["state"], unique=False
    )
    op.create_index(
        "idx_gmail_oauth_state_expires",
        "gmail_oauth_state",
        ["expires_at"],
        unique=False,
    )
    op.create_table(
        "normalized_categories",
        sa.Column("id", sa.INTEGER(), autoincrement=True, nullable=False),
        sa.Column("name", sa.VARCHAR(length=100), autoincrement=False, nullable=False),
        sa.Column("description", sa.TEXT(), autoincrement=False, nullable=True),
        sa.Column(
            "is_system",
            sa.BOOLEAN(),
            server_default=sa.text("false"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "is_active",
            sa.BOOLEAN(),
            server_default=sa.text("true"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "is_essential",
            sa.BOOLEAN(),
            server_default=sa.text("false"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "display_order",
            sa.INTEGER(),
            server_default=sa.text("0"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column("color", sa.VARCHAR(length=30), autoincrement=False, nullable=True),
        sa.Column(
            "created_at",
            postgresql.TIMESTAMP(timezone=True),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            "updated_at",
            postgresql.TIMESTAMP(timezone=True),
            server_default=sa.text("now()"),
            autoincrement=False,
            nullable=True,
        ),
        sa.PrimaryKeyConstraint("id", name="normalized_categories_pkey"),
        sa.UniqueConstraint(
            "name",
            name="normalized_categories_name_key",
            postgresql_include=[],
            postgresql_nulls_not_distinct=False,
        ),
    )
    op.create_index(
        "idx_normalized_categories_system",
        "normalized_categories",
        ["is_system"],
        unique=False,
    )
    op.create_index(
        "idx_normalized_categories_name",
        "normalized_categories",
        ["name"],
        unique=False,
    )
    op.create_index(
        "idx_normalized_categories_active",
        "normalized_categories",
        ["is_active"],
        unique=False,
    )
    # ### end Alembic commands ###
